<h1 align="center">Тестирование web приложений и API</h1>
<details><summary><b>Клиент-серверная архитектура</b></summary></br> 
  
Клиентское приложение формирует запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. Протокол описывает, по каким правилам контакт клиента и сервера установлен и действует.  
  
**Как это работает:**  
- Клиент (браузер) отправляют строку запроса (HTTP-запрос), которая создается по определенным правилам, и запрашивает нужную веб-страничку на сервере.  
- Сервер принимает запрос и ищет у себя эту веб-страницу. По результатам этого поиска создается ответ клиенту (HTTP-ответ). Этот ответ тоже оформляется по определенным правилам.  
- Если все прошло успешно и страница найдена, то в этом ответе будет передан код нужной веб-страницы + дополнительная служебная информация.  
- Если произошел какой-то сбой, то будет передан код ошибки и дополнительная служебная информация.  
  
**Архитектура клиент-сервер:**  
 - *Двухуровневая.* Сторонние ресурсы не задействованы. Одна машина обрабатывает поступившие сообщения. В этом случае сервер должен быть высокопроизводительным. Несмотря на эти жесткие требования, архитектура очень надежная. Первый уровень – клиент отправляет запрос. Второй уровень – сервером принимается сообщение, обрабатывается и отправляется ответ.  
 - *Многоуровневая.* Речь идет о любой современной архитектуре СУБД. Принципиальное отличие и особенность: запросом клиента занимаются одновременно несколько серверных устройств. Операции перераспределяются, нагрузка на серверную машину снижена и оптимальная. Единственный минус: низкая надежность по сравнению с предыдущим вариантом.  
  
Преимущества и недостатки архитектуры клиент-сервер:  
  
**Плюсы:**  
 - к клиентским рабочим станциям выдвигают низкие запросы  
 - преимущественно все вычислительные операции выполняются на серверах  
 - гибкая система  
 - реально повысить защиту локальной сети  
  
**Недостатки:**  
 - серверные машины стоят в разы дороже, чем клиентские рабочие станции  
 - обслуживание серверов доверяют только квалифицированным и профессионально подготовленным специалистам  
 - работа клиентских компьютерных устройств остановлена, если в локальной сети «полетело» серверное оборудование  
</details>  
<details><summary><b>HTTP- протокол, структура запроса и ответа</b></summary></br>  
  
**HTTP** – это протокол передачи информации в интернете, который расшифровывается как «протокол передачи гипертекста» (HyperText Transfer Protocol). Например, браузер отправляет единичный запрос на сервер, который в свою очередь обрабатывает его, формирует ответ и делится с браузером этим ответом – ресурсами в виде данных.  
  
Благодаря взаимодействию клиента и сервера в сети можно передавать данные. Изначально HTTP использовался только для гипертекстовых документов, но сейчас он может передавать любую информацию. Гипертекстовые документы также могут содержать гиперcсылки, при нажатии на которые формируется новый http-запрос, в ответе на который может содержаться другой гипертекстовый документ. Таким образом мы перемещаемся по страницам в интернете.  
  
HTTP-запрос состоит из трех элементов:  
1. стартовой строки, которая задает параметры запроса или ответа  
2. заголовка, который описывает сведения о передаче и другую служебную информацию  
3. тело (его не всегда можно встретить в структуре). Обычно в нем как раз лежат передаваемые данные. От заголовка тело отделяется пустой строкой. Важнейшим элементом структуры запроса является стартовая строка. Благодаря ей сервер понимает, что от него хотят.  
  
Вот как она устроена: **Метод + URL + HTTP/Версия**  
  
**Метод (иногда его называют HTTP-глаголом)** – описывает, какое именно действие нужно совершить со страницей. Можно придумать самые разные, но стандартных методов девять: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH. Их функциональность раскрывается в названии, они позволяют получить данные (GET), отправить данные на сервер (POST), удалить (DELETE) или заменить часть (PATCH). Чаще всего используют GET и POST, они нужны для чтения и отправки данных на сервер. Например вы зашли в соцсеть, увидели пост и решили оставить комментарий. Или зашли в интернет-магазин, решили что-то купить и оставили данные карты.  
  
**URL (Uniform Resource Locator)** – единообразный идентификатор ресурса, идентифицирует ресурс и определяет его точное местоположение. Именно с помощью URL записаны ссылки в интернете.  
  
**Версия** показывает, какую версию протокола нужно использовать в ответе сервера.  
  
HTTP-ответ строится примерно по тому же принципу, что и запрос: **HTTP/Версия + Код состояния + Пояснение**  
  
**Версия** совпадает с **версией** в запросе.  
  
**Код состояния** показывает статус запроса. Это трехзначное число, благодаря которому можно узнать, получен ли запрос, обработан ли он, какие ошибки есть. Например, одна из самых известных ошибок – 404 – сообщает о том, что сервер не нашел ресурс по адресу. Возможно, в запросе опечатка, ошибка или он не соответствует протоколу.  
  
**Чем отличаются HTTP и HTTPS**  
**HTTPS** – это расширение протокола HTTP, которое обеспечивает защиту передаваемых данных. Для сайта это важный параметр, так как шифрование позволяет ему обезопасить информацию, которую туда вводят люди (пароли, реквизиты кредитных карт), от хакерских атак. HTTP-протокол передает данные в открытую, поэтому их легко перехватить.  
  
HTTPS защищен SSL-сертификатом. Благодаря ему уязвимые данные шифруются сначала на клиенте (браузере, например) в результате чего они становятся похожи на случайный набор символов и только потом отправляются на сервер. Каждый раз при HTTP-запросе шифр меняется, поэтому успеть подобрать ключ и украсть данные довольно трудно.

</details>  

<details><summary><b>API</b></summary></br>  
</details>  

<details><summary><b>Что происходит при отправке запроса на сервер</b></summary></br>   
  
Кратко:  
1. Вычисление IP адреса для указанного url через DNS сервер
2. Отправка браузером GET-запроса на сервер
3. Получение HTTP ответа от сервера
4. Загрузка страницы и всего что ей нужно
5. Формирование DOM-дерева
6. Формирование дерева рендера и сам рендеринг
7. Выполнение скриптов

Подробно:  
  
**Отправляем GET запрос:**
- Вводим url в адресную строку http://google.com
- Посылается запрос в DNS-сервер
- DNS-сервер определит IP адрес данного домена
- Браузер связывается с веб-сервером по этому адресу с портом :80
- Браузер отправляет серверу запрос и заголовки  
- После этого браузер отправляет серверу единичную пустую строку, сигнализируя о том, что содержимое сообщения закончилось.  
  
**Получаем ответ сервера:**
- Сервер отвечает специальным кодом, который обозначает статус запроса и включает ответ следующей формы: 200 OK [заголовки ответа]
- После этого посылается пустая строка
- Затем отправляется оставшийся контент HTML-страницы www.google.com.
- В зависимости от заголовков сервер может закрыть соединение или сохранять его  
  
**Загружаем документ страницы:**  
- Движок рендеринга начинает получать содержимое запрашиваемого документа от сетевого механизма браузера.
- HTML-парсер формирует из разметки DOM-дерево.
- Браузер начинает подгружать внешние ресурсы, связанные со страницей (стили, изображения, скрипты и так далее).
- На этом этапе браузер помечает документ, как интерактивный и начинает разбирать скрипты, находящиеся в «отложенном» состоянии: то есть те из них, что должны быть исполнены после парсинга.
- После этого статус документа устанавливается в состояние «complete» и инициируется событие загрузки («load»).
Отрисовываем страницу:
- Путём перебора DOM-узлов и вычисления для каждого узла значений CSS-стилей создаётся «Дерево рендера» (Render Tree или Frame Tree).
- Происходит сам процесс рендеринга
- После завершения рендеринга, браузер исполняет JavaScript-код
- Скрипты могут потребовать обработки дополнительных сетевых запросов, изменять страницу или её шаблон, что приведёт к повторению этапа рендеринга и отрисовки"
</details>  

<details><summary><b>HTTP - методы</b></summary></br>  
  
**Метод GET** - запрашивает информацию из указанного источника и не влияет на его содержимое. Запрос доступен для кеширования данных и добавления в закладки. Длина запроса ограничена (макс. длина URL - 2048). Примечание: Строка запроса (имя/значение) отправляется в URL.  
  
Запрос:  
*GET /doc.txt HTTP/1.1  
Host: site.com*  
  
Ответ:  
*HTTP/1.1 200 OK  
Content-Type: text/plain; charset=UTF-8  
Title: Заголовок  
Text: Текст*  
  
**Метод POST** - используется для отправки данных, что может оказывать влияние на содержимое ресурса. В отличие от метода GET запросы POST не могут быть кешированы, они не остаются в истории браузера и их нельзя добавить в закладки. Запросы POST не ограничиваются в объеме. Примечание: Отправляемые данные содержатся в теле запроса.
  
Запрос:  
*POST /doc.txt HTTP/1.1  
Host: site.com  
Title=Заголовок  
Text=Текст*  
  
Если файла не было, возвращается ответ:  
*HTTP/1.1 201 Created  
Location: /doc.txt*  
  
Если файл был, возвращается ответ:  
*HTTP/1.1 200 OK  
Content-Type: text/plain; charset=UTF-8  
Добавлен контент в пустой файл «doc.txt»*  
  
**Метод HEAD**  - аналогичен методу GET, однако в ответе сервера содержится только заголовок, без тела. Обычно применяется для того, чтобы проверить, существует ли ресурс по указанному адресу, а также не изменился ли он с момента последнего обращения.  
  
Запрос:  
*HEAD /doc.txt HTTP/1.1  
Host: site.com*  
  
Ответ:  
*HTTP/1.1 200 OK  
Content-Type: text/plain; charset=UTF-8*  
  
**Метод PUT** - загружает содержимое запроса на указанный в запросе URI. Если по заданному URI ресурса нет, то сервер создает его, возвращая статус 201 (Created).  
  
Запрос:  
*PUT /doc.txt HTTP/1.1  
Host: site.com  
Title=Новый заголовок  
Text=Новый текст*  
  
Если файл был, возвращается ответ:  
*HTTP/1.1 200 OK  
Content-Type: text/plain; charset=UTF-8  
Изменен контент в файле «doc.txt»*  
  
Если файла не было, возвращается ответ:  
*HTTP/1.1 201 Created  
Content-Type: text/plain; charset=UTF-8  
Изменен контент в файле «doc.txt»*  
  
**Метод DELETE** - удаляет указанный ресурс.  
  
Запрос:  
*DELETE /doc.txt HTTP/1.1  
Host: site.com*  
  
Ответ:  
*HTTP/1.1 200 OK  
Content-Type: text/plain; charset=UTF-8  
Файл «doc.txt» удален*  
  
**Метод  OPTIONS** - используется для описания параметров коммуникации между клиентом и сервером.  
  
**Метод CONNECT** - преобразует соединение запроса в прозрачный TCP/IP-туннель.  
  
Все HTTP Methods можно разделить на три большие группы:  
**Безопасные** — не меняют данные, можно выполнять их в любой последовательности. К ним относятся GET, HEAD и OPTIONS.  
**Идемпотентные** — при повторном выполнении результаты ожидаемо одинаковые. GET, HEAD, PUT, DELETE, OPTIONS, TRACE.  
**Неидемпотентные** — при повторном выполнении результаты будут отличаться. POST и PATCH.  
</details>  
  
<details><summary><b>Коды ответов HTTP-сервера</b></summary></br>  
  
**Код состояния HTTP** - часть первой строки ответа сервера, который информирует клиента о результате запроса.   
Состоит он из трех цифр, первая из которых указывает на класс состояния. За цифрами идет фраза, которая объясняет причину ответа.  

<table>
  <tr>
    <th>Статус кода </th>
    <th>Сообщение</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td colspan="3" align = "center"><b>1xx:  Информация</b></td>
  </tr>
  <tr>
    <td>100</td>
    <td>Continue</td>
    <td>Продолжай. Сервер удовлетворён начальными сведениями о запросе, и клиент может продолжать</td>
  </tr>
  <tr>
    <td>101</td>
    <td>Switching Protocols</td>
    <td>Переключение протоколов. Клиент, пославший запрос, предлагает перейти на более подходящий для указанного ресурса протокол</td>
  </tr>
  <tr>
    <td>103</td>
    <td>Checkpoint</td>
    <td>Контрольная точка. Используется в запросах с возможностью продолжения для возобновления после прерывания запросов POST или PUT</td>
  </tr> 
  <tr>
    <td colspan="3" align = "center"><b>2xx: Успех</b></td>
  </tr>
  <tr>
    <td>200</td>
    <td>OK</td>
    <td>OK — успешный запрос. HTTP запрос успешно обработан</td>
  </tr>   
  <tr>
    <td>201</td>
    <td>Created</td>
    <td>Создано. В результате успешного выполнения запроса был создан новый ресурс</td>
  </tr> 
  <tr>
    <td>202</td>
    <td>Accepted</td>
    <td>Принято. Запрос был принят в обработку, но обработка еще не завершена</td>
  </tr> 
  <tr>
    <td>203</td>
    <td>Non-Authoritative Information</td>
    <td>Не авторитетная информация. Запрос был успешно обработан (аналогично ответу 200), но в этом случае передаваемая информация была взята не из первичного источника (например, из резервной копии или другого сервера) и может быть неактуальной</td>
  </tr>
  <tr>
    <td>204</td>
    <td>No Content</td>
    <td>Нет контента.Запрос был успешно обработан, но не вернул какой-либо контент</td>
  </tr>
  <tr>
    <td>205</td>
    <td>Reset Content</td>
    <td>Сброс контента. Запрос был обработан, но не вернул контент. При этом требуется сброс введенных данных клиентом</td>
  </tr>
  <tr>
    <td>206</td>
    <td>Partial Content</td>
    <td>Часть контента. Сервер успешно обработал только часть запроса</td>
  </tr>
  <tr>
    <td colspan="3" align = "center"><b>3xx: Перенаправление</b></td>
  </tr>  
  <tr>
    <td>300</td>
    <td>Multiple Choices</td>
    <td>Выбор из нескольких вариантов. Сервер передаёт с сообщением список из нескольких возможных вариантов перенаправления альтернатив (максимум 5 вариантов). Клиент может выбрать один из них</td>
  </tr>
  <tr>
    <td>301</td>
    <td>Moved Permanently</td>
    <td>Окончательно перемещено. Страница окончательно перемещена на другой URL</td>
  </tr>
  <tr>
    <td>302</td>
    <td>Found</td>
    <td>Найдено /временно перемещено. Запрашиваемая страница была найдена / временно перенесена на другой URL</td>
  </tr>  
  <tr>
    <td>303</td>
    <td>See Other</td>
    <td>Cмотрите другое. Запрашиваемая страница не найдена по другому URL</td>
  </tr>
  <tr>
    <td>304</td>
    <td>Not Modified</td>
    <td>Без изменений. Запрашиваемый документ не был изменен с момента последнего запроса</td>
  </tr> 
  <tr>
    <td>306</td>
    <td>Switch Proxy</td>
    <td>Использовавшийся раньше код ответа, в настоящий момент зарезервирован</td>
  </tr>  
  <tr>
    <td>307</td>
    <td>Temporary Redirect</td>
    <td>Временный редирект. Запрашиваемый ресурс на короткое время доступен по другому URL</td>
  </tr> 
  <tr>
    <td>308</td>
    <td>Resume Incomplete</td>
    <td>Перемещено навсегда / возобновление после прерывания. Запрашиваемая страница была перенесена на новый URL на постоянной основе (редирект 308 сохраняет HTTP метод, в отличии от 301-го, где возможно его изменение), либо предлагается возобновить прерванный PUT или POST запрос</td>
  </tr>
  <tr>
    <td colspan="3" align = "center"><b>4xx: Ошибки клиента</b></td>
  </tr> 
  <tr>
    <td>400</td>
    <td>Bad Request</td>
    <td>Некорректный запрос. Запрос не может быть обработан, поскольку содержит синтаксическую ошибку</td>
  </tr>
  <tr>
    <td>401</td>
    <td>Unauthorized</td>
    <td>Не авторизован. Запрос обрабатывается, но доступ к запрашиваемому ресурсу не предоставляется, поскольку клиент не авторизован</td>
  </tr> 
  <tr>
    <td>402</td>
    <td>Payment Required</td>
    <td>Не используется. Зарезервирован для использования в будущем</td>
  </tr> 
  <tr>
    <td>403</td>
    <td>Forbidden</td>
    <td>Запрещено. Сервер понял запрос, но он не выполняет его из-за ограничений прав доступа к указанному ресурсу</td>
  </tr>
  <tr>
    <td>404</td>
    <td>Not Found</td>
    <td>Не найдено. Запрашиваемая страница не найдена. Сервер понял запрос, но не нашёл соответствующего ресурса по указанному URL (Самая распространенная ошибка в Интернете, возникает из-за неправильно указанного URL)</td>
  </tr>
  <tr>
    <td>405</td>
    <td>Method Not Allowed</td>
    <td>Mетод не поддерживается. Запрос был сделан методом, который не поддерживается данным ресурсом</td>
  </tr>
  <tr>
    <td>406</td>
    <td>Not Acceptable</td>
    <td>Не принимается. Сервер может сгенерировать только такой ответ, который клиент не принимает. (например, на другом языке)</td>
  </tr>
  <tr>
    <td>407</td>
    <td>Proxy Authentication Required</td>
    <td>Требуется аутентификация прокси. Ответ аналогичен коду 401 за исключением того, что аутентификация производится для прокси-сервера</td>
  </tr>
  <tr>
    <td>408</td>
    <td>Request Timeout</td>
    <td>Время ожидания истекло. Запрос клиента к серверу занял слишком много времени</td>
  </tr>
  <tr>
    <td>409</td>
    <td>Conflict</td>
    <td>Конфликт. Запрос не может быть обработан по причине конфликта с другим запросом или конфигурацией сервера</td>
  </tr>  
  <tr>
    <td>410</td>
    <td>Gone</td>
    <td>Недоступен. Доступный по указанному URL раньше был доступен, но был удалён или недоступен</td>
  </tr>
  <tr>
    <td>411</td>
    <td>Length Required</td>
    <td>Нужна длина. Длина контента не определена, и сервер не принимает запрос без этого. Повторный запрос должен содержать заголовок ""Content-Length""</td>
  </tr>
  <tr>
    <td>412</td>
    <td>Precondition Failed</td>
    <td>Не выполнено предварительное условие. Предварительное условие, указанное в запросе, не было выполнено</td>
  </tr>
  <tr>
    <td>413</td>
    <td>Request Entity Too Large</td>
    <td>Слишком большой запрос. Размер запроса превышает максимальный размер запроса, принимаемого сервером</td>
  </tr>  
  <tr>
    <td>414</td>
    <td>Request-URI Too Long</td>
    <td>Слишком длинный URI. Серверу не удается обработать запрос по причине длинного URI. Такая ошибка может возникнуть, когда клиент пытается передать длинные параметры через метод GET, а не POST</td>
  </tr>
  <tr>
    <td>415</td>
    <td>Unsupported Media Type</td>
    <td>Неподдерживаемый формат. Формат не поддерживается, и сервер не может принять запрос</td>
  </tr>
  <tr>
    <td>416</td>
    <td>Requested Range Not Satisfiable</td>
    <td>Недопустимый диапазон. Диапазон байтов, запрошенный клиентом, находится за пределами ресурса</td>
  </tr>
  <tr>
    <td>417</td>
    <td>Expectation Failed</td>
    <td>Ожидания не оправдались. Сервер не может удовлетворить требования заголовка Expect, так как поле заголовка не соответствует ожиданиям</td>
  </tr>
  <tr>
    <td colspan="3" align = "center"><b>5xx: Ошибки сервера</b></td>
  </tr>
  <tr>
    <td>500</td>
    <td>Internal Server Error</td>
    <td>Внутренняя ошибка сервера. Любая внутренняя ошибка сервера, которую сервер не может конкретизировать</td>
  </tr>
  <tr>
    <td>501</td>
    <td>Not Implemented</td>
    <td>Не реализовано. Сервер не распознает указанного в запросе метода и не может обработать запрос</td>
  </tr>
  <tr>
    <td>502</td>
    <td>Bad Gateway</td>
    <td>Ошибка шлюза. Сервер, выступая в роли шлюза или прокси-сервера, получил недействительное ответное сообщение от вышестоящего сервера</td>
  </tr>
  <tr>
    <td>503</td>
    <td>Service Unavailable</td>
    <td>Сервис недоступен. Сервер не доступен в данный момент (перегружен, отключен, на техническом обслуживании)</td>
  </tr>
  <tr>
    <td>504</td>
    <td>Gateway Timeout</td>
    <td>Время ожидания ответа шлюзом истекло. Сервер, выступая в роли шлюза или прокси-сервера, не получил ответа от вышестоящего сервера в отведенное время</td>
  </tr>
  <tr>
    <td>505</td>
    <td>HTTP Version Not Supported</td>
    <td>Версия HTTP не поддерживается. Версия протокола HTTP, используемая в запросе, не поддерживается сервером</td>
  </tr>
  <tr>
    <td>511</td>
    <td>Network Authentication Required</td>
    <td>ребуется аутентификация. Для получения доступа к сети, клиент должен пройти аутентификацию. Ошибка генерируется сервером-посредником, к примеру, сервером интернет-провайдера, если нужно ввести пароль для получения доступа к сети через платную точку доступа</td>
  </tr>  
</table>  
</details>
   
<details><summary><b>Работа с сетями</b></summary></br> 
</details>
  
<details><summary><b>Кэш, куки, веб-сокет</b></summary></br> 
  
**Кэшем** называется место на диске или в оперативной памяти, где хранится временная информация. Наиболее распространенный тип кэша — браузерный, он помогает сэкономить трафик и время загрузки страниц (что является важным показателем эффективной работы сайта и положительно сказывается на пользовательском опыте). С помощью технологии кэширования HTML-страниц, изображений и других веб-элементов сайты загружаются значительно быстрее при их повторном посещении. Кэш здесь выступает своеобразным промежуточным буфером. Для отображения веб-страниц браузер обращается к кэшу, а остальное содержимое запрашивает с сервера.  
  
Браузерное кэширование для клиент-серверного приложения схематично можно представить себе так:  
 - Клиент (браузер) отправляет запрос на сервер с целью загрузить определенную веб-страницу  
 - Сервер на своей стороне формирует ответ и возвращает клиенту пакеты данных, содержащих элементы веб-страницы (HTML и CSS файлы, скрипты, мультимедиа и т.д.)  
 - Браузер получает ответ от сервера и отображает страницу, при этом кэшируя некоторые данные  

**Cookie** — это небольшие служебные файлы, которые хранятся на компьютере пользователя. Они содержат данные, относящиеся к пользователю, его предпочтениям и действиям на конкретном сайте: данные для авторизации (логин и пароль), индивидуальные настройки, посещенные страницы, совершенные действия, товары в корзине, дата и время посещения и т.д. Когда пользователь повторно заходит на сайт, браузер отправляет cookie на сервер, чтобы рассказать сайту о предыдущих активностях пользователя. Cookie обладают определенным сроком жизни, по истечении которого они удаляются.  
  
**Зачем нужны cookie?**   
Cookie помогают улучшить пользовательский опыт использования интернет-ресурсов, сделать работу в интернете более комфортной и быстрой.  
Приведем примеры использования:  
 - Аутентификация пользователя: благодаря cookie пользователям не приходится при каждом посещении сайта заново вводить логин и пароль. Нагрузка на сервер несколько снижается (поскольку данные подтягиваются не напрямую с сервера)  
 - Покупки в интернет-магазинах: cookie позволяют запоминать выбранные товары, так, что они сохраняются в корзине, даже если закрыть сайт/приложение  
 - Персональные предпочтения и настройки пользователя: сохранение этих данных помогают не настраивать заново при каждом посещении регион, язык, стиль оформления и т.д.   
В соответствии с Общим регламентом по защите данных (GDPR) веб-сайты должны оповещать пользователей об использовании файлов cookie, как они и делают с помощью всплывающих окон. Отказаться от использования можно (если такая возможность предоставляется), по правилам GDPR доступ к сервису при этом не будет запрещен или ограничен. Однако надо помнить, что в этом случае пользоваться, например, интернет-магазином станет неудобно. 
  
**Разница между куки и кэш**  
 - Cookie хранят данные, относящиеся к пользователю, его предпочтениям, настройкам и действиям на веб-страницах и используются для более комфортного использования интернет-ресурсов. Кэш хранит некоторое содержимое веб-сайта и используется для ускорения доступа к данным, снижения нагрузки на сервер, более быстрой загрузки сайта. 
 - Cookie-файлы весят обычно немного, поскольку представляют собой текстовые документы, в то время как кэш может занимать много места.  
 - Cookie обычно удаляются по истечению срока действия, в то время как кэш хранится на устройстве до тех пор, пока пользователь вручную его не очистит.  
  
**Веб-сокеты (Web Sockets)** — это передовая технология, которая позволяет создавать интерактивное соединение между клиентом (браузером) и сервером для обмена сообщениями в режиме реального времени. Веб-сокеты, в отличие от HTTP, позволяют работать с двунаправленным потоком данных, что делает эту технологию совершенно уникальной.  
  
**WebSocket** особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, чат-приложения, работающие в реальном времени, и т.д.
</details>
  
<details><summary><b>HTML, CSS, JS</b></summary></br> 

</details>
<details><summary><b>Работа с DevTools</b></summary></br> 

</details>
<details><summary><b>Веб-сервисы. Особенности (и отличия) REST и SOAP</b></summary></br> 
  
**Веб-сервисы (или веб-службы)** — это технология, позволяющая системам обмениваться данными друг с другом через сетевое подключение. Обычно веб-сервисы работают поверх протокола HTTP или протокола более высокого уровня. Веб-сервис — просто адрес, ссылка, обращение к которому позволяет получить данные или выполнить действие.  
  
Главное отличие веб-сервиса от других способов передачи данных: стандартизированность. Приняв решение использовать веб-сервисы, можно сразу переходить к структуре данных и доступным функциям. Например, В SOAP (как более строгом протоколе), уже решён вопрос уведомления об ошибках.  
  
Самые известные способы реализации веб-сервисов:  
 - XML-RPC (XML Remote Procedure Call) — протокол удаленного вызова процедур с использованием XML. Прародитель SOAP. Предельно прост в реализации  
 - SOAP (Simple Object Access Protocol) — стандартный протокол по версии W3C. Четко структурирован и задокументирован  
 - JSON-RPC (JSON Remote Procedure Call) — более современный аналог XML-RPC. Основное отличие — данные передаются в формате JSON  
 - REST (Representational State Transfer) — архитектурный стиль взаимодействия компьютерных систем в сети основанный на методах протокола HTTP  
 - специализированные протоколы для конкретного вида задач, такие как GraphQL  
 - менее распространенный, но более эффективный gRPC, передающий данные в бинарном виде и использующий HTTP/2 в качестве транспорта  
  
**REST** — это архитектурный стиль.  
Специфика REST — использование HTTP в качестве транспортного протокола. Он подразумевает наилучшее использование функций, предоставляемых HTTP — методы запросов, заголовки запросов, ответы, заголовки ответов и т. д.  
  
**Преимущества:**
 - простота реализации  
 - экономичность в плане ресурсов  
 - не требует программных надстроек (json_decode есть почти в каждом языке)  
  
**Недостатки:**
 - отсутствие спецификации  
 - неоднозначность методов управления данными  
<img width = '700' src="https://www.intervolga.ru/upload/medialibrary/fe6/fe6bf6d5c55ceeb7705b185e5ed02b4c.png" width="550" />
  
**Где REST лучше использовать и почему:**  
1. В сервисах, которые будут использоваться из javascript. Тут и говорить нечего, javascript хорошо работает с json, поэтому именно его и надо предоставлять  
2. В сервисах, которые будут использоваться из языков, в которых нет возможности сгенерировать прокси клиента. Это Objective-C, например. Не нужно парсить вручную SOAP-конверт, это незачем  
3. Когда существуют очень высокие требования к производительности. Это, как правило, очень интенсивно используемые API, вроде Twitter API или Google API  
  
**SOAP** — это формат обмена сообщениями. 
  
**Преимущества:**
 - отраслевой стандарт по версии W3C  
 - наличие строгой спецификации  
 - широкая поддержка в продуктах Microsoft  
 - однозначность  
   
**Недостатки:**  
 - сложность реализации  
 - сложность / ресурсоемкость парсинга XML-данных  
  
Специфика SOAP — это формат обмена данными. С SOAP это всегда SOAP-XML, который представляет собой XML, включающий:  
— *Envelope (конверт)* – корневой элемент, который определяет сообщение и пространство имен, использованное в документе  
— *Header (заголовок)* – содержит атрибуты сообщения, например: информация о безопасности или о сетевой маршрутизации  
— *Body (тело)* – содержит сообщение, которым обмениваются приложения  
— *Fault* – необязательный элемент, который предоставляет информацию об ошибках, которые произошли при обработке сообщений. И запрос, и ответ должны соответствовать структуре SOAP  
 <img width = '700' src="https://www.intervolga.ru/upload/medialibrary/20f/20f87aba3e6cd7ba538301283daee271.png" width="550" />
  
SOAP – это целое семейство протоколов и стандартов, откуда напрямую вытекает, что это более тяжеловесный и сложный вариант с точки зрения машинной обработки. Поэтому REST работает быстрее.  
  
**Формат обмена сообщениями**  
 - В SOAP используете формат SOAP XML для запросов и ответов.  
 - В REST такого фиксированного формата нет. Вы можете обмениваться сообщениями на основе XML, JSON или любого другого удобного формата. JSON является самым популярным среди используемых форматов.  
  
**Определения услуг**  
 - SOAP использует WSDL (Web Services Description Language) — язык описания веб-сервисов и доступа к ним, основанный на языке XML.  
 - REST не имеет стандартного языка определения сервиса. Несмотря на то, что WADL был одним из первых предложенных стандартов, он не очень популярен. Более популярно использование Swagger или Open API.  
  
**Простота реализации**  
RESTFful веб-сервисы, как правило, гораздо проще реализовать, чем веб-сервисы на основе SOAP.  
REST обычно использует JSON, который легче анализировать и обрабатывать. В дополнение к этому, REST не требует наличия определения службы для предоставления веб-службы.  
Однако в случае SOAP вам необходимо определить свой сервис с использованием WSDL, и при обработке и анализе сообщений SOAP-XML возникают большие накладные расходы.  
  
**«REST vs SOAP» можно перефразировать в «Простота vs Стандарты»**  
  
Пример: *букмекерская контора заказала сервис для работы с футбольной статистикой. Пользовательский функционал – получить список матчей, получить детали о матче. Для редакторов – редактировать (Create, Edit, Delete) список матчей, редактировать детали матча. Для такой задачи однозначно надо выбирать подход REST и получать бенефиты от его простоты и естественности во взаимодействии с HTTP. Не нужны нам здесь SOAP-конверты, SOAP-главпочтамты и SOAP-авиапочта, которая может использовать любую марку самолета.*  
  
Теперь пример посложнее: *та же букмекерская контора захотела API для ставок на live матчи. Эта процедура включает в себя многочисленные проверки, например, продолжает ли ставка быть актуальной, не изменился ли коэффициент, не превышена ли максимальная сумма ставки для маркета. После этого происходит денежная транзакция, результаты которой записываются в основную и в резервные базы данных. Лишь после этого клиенту приходит ответ об успешности операции. Здесь явно прослеживается ориентация на операции, имеются повышенные требования к безопасности и устойчивости приложения, поэтому целесообразно использовать SOAP.*  
</details>
<details><summary><b>Анализаторы траффика Charles Proxy/Fiddler</b></summary></br> 

</details>
<details><summary><b>Знание Postman, SoapUI</b></summary></br> 

</details>
<details><summary><b>Идентификация, аутентификация, авторизация</b></summary></br> 
  
**Идентификация** — это процедура распознавания субъекта по его идентификатору (проще говоря, это определение имени, логина или номера)    
Идентификация выполняется при попытке войти в какую-либо систему (например, в операционную систему или в сервис электронной почты)  
  
**Аутентификация** – это процедура проверки подлинности (пользователя проверяют с помощью пароля, письмо проверяют по электронной подписи и т.д.)  
Чтобы определить чью-то подлинность, можно воспользоваться тремя факторами:  
 - Пароль – то, что мы знаем (слово, PIN-код, код для замка, графический ключ)
 - Устройство – то, что мы имеем (пластиковая карта, ключ от замка, USB-ключ)
 - Биометрика – то, что является частью нас (отпечаток пальца, портрет, сетчатка глаза)

    + **Многофакторная аутентификация**  
Представляет собой метод, при котором пользователю для доступа к учетной записи или подтверждения операции с денежными средствами необходимо двумя различными факторами доказать, что именно он владелец учетной записи или что именно он осуществляет вход.  
Среди видов многофакторной аутентификации наиболее распространена двухфакторная аутентификация (2FA — 2-factor authentication) – метод, при котором пользователю для получения доступа необходимо предоставить два разных типа аутентификационных данных, например, что-то известное только пользователю (пароль) и что-то присущее только пользователю (отпечаток пальца).
  
    + **Однофакторная двухэтапная аутентификация**  
Благодаря тому, что смартфоны стали неотъемлемой частью нашей жизни, именно они стали одним из способов подтверждения личности пользователя. Они являются токенами для доступа к различным ресурсам. В этом случае одноразовый пароль генерируется или с помощью специального приложения, или приходит по SMS – это максимально простой для пользователя метод.  
<img width = '800' src="https://safe-surf.ru/upload/medialibrary/813/autent.png" width="550" />  
    
**Авторизация** – это предоставление доступа к какому-либо ресурсу  
    
Пример: *пользователь хочет войти в свой аккаунт Google (Google подходит лучше всего, потому что там процедура входа явным образом разбита на несколько простейших этапов)*   
 - Сачала система запрашивает логин, пользователь его указывает, система распознает его как существующий — это **идентификация**. После этого Google просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь действительно настоящий, ведь пароль совпал, — это **аутентификация**  
 - Возможно, Google дополнительно спросит еще и одноразовый код из SMS или приложения. Если пользователь и его правильно введет, то система окончательно согласится с тем, что он настоящий владелец аккаунта, — это **двухфакторная аутентификация**  
 - После этого система предоставит пользователю право читать письма в его почтовом ящике и все остальное — это **авторизация**  
  
</details>
<details><summary><b>Виды авторизация</b></summary></br> 

</details>
<details><summary><b>Тестирование веб форм и веб элементов</b></summary></br> 

</details> 
<details><summary><b>Анализ логов (Kibana, Elasticsearch)</b></summary></br> 

</details>
<img width = '700' src="https://www.intervolga.ru/upload/medialibrary/20f/20f87aba3e6cd7ba538301283daee271.png" width="550" />
  
