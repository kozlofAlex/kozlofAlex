<h1 align="center">Тестирование web приложений и API</h1>
<details><summary><b>Клиент-серверная архитектура</b></summary></br> 
  
Клиентское приложение формирует запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. Протокол описывает, по каким правилам контакт клиента и сервера установлен и действует.  
  
**Как это работает:**  
- Клиент (браузер) отправляют строку запроса (HTTP-запрос), которая создается по определенным правилам, и запрашивает нужную веб-страничку на сервере.  
- Сервер принимает запрос и ищет у себя эту веб-страницу. По результатам этого поиска создается ответ клиенту (HTTP-ответ). Этот ответ тоже оформляется по определенным правилам.  
- Если все прошло успешно и страница найдена, то в этом ответе будет передан код нужной веб-страницы + дополнительная служебная информация.  
- Если произошел какой-то сбой, то будет передан код ошибки и дополнительная служебная информация.  
  
**Архитектура клиент-сервер:**  
 - *Двухуровневая.* Сторонние ресурсы не задействованы. Одна машина обрабатывает поступившие сообщения. В этом случае сервер должен быть высокопроизводительным. Несмотря на эти жесткие требования, архитектура очень надежная. Первый уровень – клиент отправляет запрос. Второй уровень – сервером принимается сообщение, обрабатывается и отправляется ответ.  
 - *Многоуровневая.* Речь идет о любой современной архитектуре СУБД. Принципиальное отличие и особенность: запросом клиента занимаются одновременно несколько серверных устройств. Операции перераспределяются, нагрузка на серверную машину снижена и оптимальная. Единственный минус: низкая надежность по сравнению с предыдущим вариантом.  
  
Преимущества и недостатки архитектуры клиент-сервер:  
  
**Плюсы:**  
 - к клиентским рабочим станциям выдвигают низкие запросы  
 - преимущественно все вычислительные операции выполняются на серверах  
 - гибкая система  
 - реально повысить защиту локальной сети  
  
**Недостатки:**  
 - серверные машины стоят в разы дороже, чем клиентские рабочие станции  
 - обслуживание серверов доверяют только квалифицированным и профессионально подготовленным специалистам  
 - работа клиентских компьютерных устройств остановлена, если в локальной сети «полетело» серверное оборудование  
</details>  

<details><summary><b>HTTP- протокол, структура запроса и ответа</b></summary></br>  
  
**HTTP** – это протокол передачи информации в интернете, который расшифровывается как «протокол передачи гипертекста» (HyperText Transfer Protocol). Например, браузер отправляет единичный запрос на сервер, который в свою очередь обрабатывает его, формирует ответ и делится с браузером этим ответом – ресурсами в виде данных.  
  
Благодаря взаимодействию клиента и сервера в сети можно передавать данные. Изначально HTTP использовался только для гипертекстовых документов, но сейчас он может передавать любую информацию. Гипертекстовые документы также могут содержать гиперcсылки, при нажатии на которые формируется новый http-запрос, в ответе на который может содержаться другой гипертекстовый документ. Таким образом мы перемещаемся по страницам в интернете.  
  
HTTP-запрос состоит из трех элементов:  
1. стартовой строки, которая задает параметры запроса или ответа  
2. заголовка, который описывает сведения о передаче и другую служебную информацию  
3. тело (его не всегда можно встретить в структуре). Обычно в нем как раз лежат передаваемые данные. От заголовка тело отделяется пустой строкой. Важнейшим элементом структуры запроса является стартовая строка. Благодаря ей сервер понимает, что от него хотят.  
  
Вот как она устроена: **Метод + URL + HTTP/Версия**  
  
**Метод (иногда его называют HTTP-глаголом)** – описывает, какое именно действие нужно совершить со страницей. Можно придумать самые разные, но стандартных методов девять: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH. Их функциональность раскрывается в названии, они позволяют получить данные (GET), отправить данные на сервер (POST), удалить (DELETE) или заменить часть (PATCH). Чаще всего используют GET и POST, они нужны для чтения и отправки данных на сервер. Например вы зашли в соцсеть, увидели пост и решили оставить комментарий. Или зашли в интернет-магазин, решили что-то купить и оставили данные карты.  
  
**URL (Uniform Resource Locator)** – единообразный идентификатор ресурса, идентифицирует ресурс и определяет его точное местоположение. Именно с помощью URL записаны ссылки в интернете.  
  
**Версия** показывает, какую версию протокола нужно использовать в ответе сервера.  
  
HTTP-ответ строится примерно по тому же принципу, что и запрос: **HTTP/Версия + Код состояния + Пояснение**  
  
**Версия** совпадает с **версией** в запросе.  
  
**Код состояния** показывает статус запроса. Это трехзначное число, благодаря которому можно узнать, получен ли запрос, обработан ли он, какие ошибки есть. Например, одна из самых известных ошибок – 404 – сообщает о том, что сервер не нашел ресурс по адресу. Возможно, в запросе опечатка, ошибка или он не соответствует протоколу.  
  
**Чем отличаются HTTP и HTTPS**  
**HTTPS** – это расширение протокола HTTP, которое обеспечивает защиту передаваемых данных. Для сайта это важный параметр, так как шифрование позволяет ему обезопасить информацию, которую туда вводят люди (пароли, реквизиты кредитных карт), от хакерских атак. HTTP-протокол передает данные в открытую, поэтому их легко перехватить.  
  
HTTPS защищен SSL-сертификатом. Благодаря ему уязвимые данные шифруются сначала на клиенте (браузере, например) в результате чего они становятся похожи на случайный набор символов и только потом отправляются на сервер. Каждый раз при HTTP-запросе шифр меняется, поэтому успеть подобрать ключ и украсть данные довольно трудно.

</details>  

<details><summary><b>API</b></summary></br>  
  
**API (аббревиатура от Application Programming Interface)** – интерфейс программирования приложений, позволяющий сервисам взаимодействовать, получать доступ и обмениваться данными.  
По сути API выступает в роли посредника между двумя приложениями или сервисами – оно предоставляет решения (классы, функции, структуры), реализованные в одном сервисе, и создает среду для создания нового приложения с применением этих решений.  
Пример *использования API, знакомый большинству интернет-пользователей – регистрация на сайте с помощью аккаунта социальной сети. Благодаря API сайт может подключиться к базе данных социальной сети и получить нужную ему информацию.*   
  
API можно подразделять по типу доступа:  
 - **Внутренние API** - доступны внутренним разработчикам компании и сотрудникам, используются для оптимизации рабочих процессов и снижения затрат  
 - **Партнерские API** - доступны бизнес-партнерам и потребителям продукта или услуги, используются для оптимизации процессов и разработки  
 - **Публичные API**  - доступны всем, используются для создания новых сервисов и популяризации существующего направления  
  
**Плюсы API:**  
 - Самый главный плюс работы с API – это экономия времени при разработке собственных сервисов. Программист получает готовые решения и ему не нужно тратить время на написание кода для функционала, который уже давно реализован  
 - В API могут учитываться нюансы, которые сторонний разработчик может не учесть или просто не знать, API дает приложениям определенную системность и предсказуемость – одна и та же функция с помощью API может быть реализована в разных приложениях так, что будет понятна и знакома всем пользователям  
 - API дает сторонним разработчикам доступ к закрытым сервисам  
  
**Минусы:**  
 - Если в основной сервис вносятся изменения и доработки, в API они могут попасть не сразу  
 - Разработчику доступны готовые решения, как именно они реализованы и как выглядит исходный код, он не знает  
 - API предназначен в первую очередь для общего использования, он может не подойти для создания какого-то особого функционала  
  
**Использование API на практике**  
Самые распространенные способы использования различных API разработчиками и компаниями по всему миру:  
1. Добавление в свои сервисы функционала социальных сетей и мессенджеров, калькуляторов валют, погоды и т.д. Стандартное рабочее решение, которое не требует долгих месяцев программирования  
2. Доступ к популярному сервису или хранилищу данных с соблюдением всех требований безопасности  
3. Внутренние нужды компании, например, разработка мобильного приложения под сайт, с последующей систематизацией всех данных  
  
</details>  

<details><summary><b>Что происходит при отправке запроса на сервер</b></summary></br>   
  
Кратко:  
1. Вычисление IP адреса для указанного url через DNS сервер
2. Отправка браузером GET-запроса на сервер
3. Получение HTTP ответа от сервера
4. Загрузка страницы и всего что ей нужно
5. Формирование DOM-дерева
6. Формирование дерева рендера и сам рендеринг
7. Выполнение скриптов

Подробно:  
  
**Отправляем GET запрос:**
- Вводим url в адресную строку http://google.com
- Посылается запрос в DNS-сервер
- DNS-сервер определит IP адрес данного домена
- Браузер связывается с веб-сервером по этому адресу с портом :80
- Браузер отправляет серверу запрос и заголовки  
- После этого браузер отправляет серверу единичную пустую строку, сигнализируя о том, что содержимое сообщения закончилось.  
  
**Получаем ответ сервера:**
- Сервер отвечает специальным кодом, который обозначает статус запроса и включает ответ следующей формы: 200 OK [заголовки ответа]
- После этого посылается пустая строка
- Затем отправляется оставшийся контент HTML-страницы www.google.com.
- В зависимости от заголовков сервер может закрыть соединение или сохранять его  
  
**Загружаем документ страницы:**  
- Движок рендеринга начинает получать содержимое запрашиваемого документа от сетевого механизма браузера.
- HTML-парсер формирует из разметки DOM-дерево.
- Браузер начинает подгружать внешние ресурсы, связанные со страницей (стили, изображения, скрипты и так далее).
- На этом этапе браузер помечает документ, как интерактивный и начинает разбирать скрипты, находящиеся в «отложенном» состоянии: то есть те из них, что должны быть исполнены после парсинга.
- После этого статус документа устанавливается в состояние «complete» и инициируется событие загрузки («load»).
Отрисовываем страницу:
- Путём перебора DOM-узлов и вычисления для каждого узла значений CSS-стилей создаётся «Дерево рендера» (Render Tree или Frame Tree).
- Происходит сам процесс рендеринга
- После завершения рендеринга, браузер исполняет JavaScript-код
- Скрипты могут потребовать обработки дополнительных сетевых запросов, изменять страницу или её шаблон, что приведёт к повторению этапа рендеринга и отрисовки"
</details>  

<details><summary><b>HTTP - методы</b></summary></br>  
  
**Метод GET** - запрашивает информацию из указанного источника и не влияет на его содержимое. Запрос доступен для кеширования данных и добавления в закладки. Длина запроса ограничена (макс. длина URL - 2048). Примечание: Строка запроса (имя/значение) отправляется в URL.  
  
Запрос:  
*GET /doc.txt HTTP/1.1  
Host: site.com*  
  
Ответ:  
*HTTP/1.1 200 OK  
Content-Type: text/plain; charset=UTF-8  
Title: Заголовок  
Text: Текст*  
  
**Метод POST** - используется для отправки данных, что может оказывать влияние на содержимое ресурса. В отличие от метода GET запросы POST не могут быть кешированы, они не остаются в истории браузера и их нельзя добавить в закладки. Запросы POST не ограничиваются в объеме. Примечание: Отправляемые данные содержатся в теле запроса.
  
Запрос:  
*POST /doc.txt HTTP/1.1  
Host: site.com  
Title=Заголовок  
Text=Текст*  
  
Если файла не было, возвращается ответ:  
*HTTP/1.1 201 Created  
Location: /doc.txt*  
  
Если файл был, возвращается ответ:  
*HTTP/1.1 200 OK  
Content-Type: text/plain; charset=UTF-8  
Добавлен контент в пустой файл «doc.txt»*  
  
**Метод HEAD**  - аналогичен методу GET, однако в ответе сервера содержится только заголовок, без тела. Обычно применяется для того, чтобы проверить, существует ли ресурс по указанному адресу, а также не изменился ли он с момента последнего обращения.  
  
Запрос:  
*HEAD /doc.txt HTTP/1.1  
Host: site.com*  
  
Ответ:  
*HTTP/1.1 200 OK  
Content-Type: text/plain; charset=UTF-8*  
  
**Метод PUT** - загружает содержимое запроса на указанный в запросе URI. Если по заданному URI ресурса нет, то сервер создает его, возвращая статус 201 (Created).  
  
Запрос:  
*PUT /doc.txt HTTP/1.1  
Host: site.com  
Title=Новый заголовок  
Text=Новый текст*  
  
Если файл был, возвращается ответ:  
*HTTP/1.1 200 OK  
Content-Type: text/plain; charset=UTF-8  
Изменен контент в файле «doc.txt»*  
  
Если файла не было, возвращается ответ:  
*HTTP/1.1 201 Created  
Content-Type: text/plain; charset=UTF-8  
Изменен контент в файле «doc.txt»*  
  
**Метод DELETE** - удаляет указанный ресурс.  
  
Запрос:  
*DELETE /doc.txt HTTP/1.1  
Host: site.com*  
  
Ответ:  
*HTTP/1.1 200 OK  
Content-Type: text/plain; charset=UTF-8  
Файл «doc.txt» удален*  
  
**Метод  OPTIONS** - используется для описания параметров коммуникации между клиентом и сервером.  
  
**Метод CONNECT** - преобразует соединение запроса в прозрачный TCP/IP-туннель.  
  
Все HTTP Methods можно разделить на три большие группы:  
**Безопасные** — не меняют данные, можно выполнять их в любой последовательности. К ним относятся GET, HEAD и OPTIONS.  
**Идемпотентные** — при повторном выполнении результаты ожидаемо одинаковые. GET, HEAD, PUT, DELETE, OPTIONS, TRACE.  
**Неидемпотентные** — при повторном выполнении результаты будут отличаться. POST и PATCH.  
</details>  
  
<details><summary><b>Коды ответов HTTP-сервера</b></summary></br>  
  
**Код состояния HTTP** - часть первой строки ответа сервера, который информирует клиента о результате запроса.   
Состоит он из трех цифр, первая из которых указывает на класс состояния. За цифрами идет фраза, которая объясняет причину ответа.  
  
<table>
  <tr>
    <th>Статус кода </th>
    <th>Сообщение</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td colspan="3" align = "center"><b>1xx:  Информация</b></td>
  </tr>
  <tr>
    <td>100</td>
    <td>Continue</td>
    <td>Продолжай. Сервер удовлетворён начальными сведениями о запросе, и клиент может продолжать</td>
  </tr>
  <tr>
    <td>101</td>
    <td>Switching Protocols</td>
    <td>Переключение протоколов. Клиент, пославший запрос, предлагает перейти на более подходящий для указанного ресурса протокол</td>
  </tr>
  <tr>
    <td>103</td>
    <td>Checkpoint</td>
    <td>Контрольная точка. Используется в запросах с возможностью продолжения для возобновления после прерывания запросов POST или PUT</td>
  </tr> 
  <tr>
    <td colspan="3" align = "center"><b>2xx: Успех</b></td>
  </tr>
  <tr>
    <td>200</td>
    <td>OK</td>
    <td>OK — успешный запрос. HTTP запрос успешно обработан</td>
  </tr>   
  <tr>
    <td>201</td>
    <td>Created</td>
    <td>Создано. В результате успешного выполнения запроса был создан новый ресурс</td>
  </tr> 
  <tr>
    <td>202</td>
    <td>Accepted</td>
    <td>Принято. Запрос был принят в обработку, но обработка еще не завершена</td>
  </tr> 
  <tr>
    <td>203</td>
    <td>Non-Authoritative Information</td>
    <td>Не авторитетная информация. Запрос был успешно обработан (аналогично ответу 200), но в этом случае передаваемая информация была взята не из первичного источника (например, из резервной копии или другого сервера) и может быть неактуальной</td>
  </tr>
  <tr>
    <td>204</td>
    <td>No Content</td>
    <td>Нет контента.Запрос был успешно обработан, но не вернул какой-либо контент</td>
  </tr>
  <tr>
    <td>205</td>
    <td>Reset Content</td>
    <td>Сброс контента. Запрос был обработан, но не вернул контент. При этом требуется сброс введенных данных клиентом</td>
  </tr>
  <tr>
    <td>206</td>
    <td>Partial Content</td>
    <td>Часть контента. Сервер успешно обработал только часть запроса</td>
  </tr>
  <tr>
    <td colspan="3" align = "center"><b>3xx: Перенаправление</b></td>
  </tr>  
  <tr>
    <td>300</td>
    <td>Multiple Choices</td>
    <td>Выбор из нескольких вариантов. Сервер передаёт с сообщением список из нескольких возможных вариантов перенаправления альтернатив (максимум 5 вариантов). Клиент может выбрать один из них</td>
  </tr>
  <tr>
    <td>301</td>
    <td>Moved Permanently</td>
    <td>Окончательно перемещено. Страница окончательно перемещена на другой URL</td>
  </tr>
  <tr>
    <td>302</td>
    <td>Found</td>
    <td>Найдено /временно перемещено. Запрашиваемая страница была найдена / временно перенесена на другой URL</td>
  </tr>  
  <tr>
    <td>303</td>
    <td>See Other</td>
    <td>Cмотрите другое. Запрашиваемая страница не найдена по другому URL</td>
  </tr>
  <tr>
    <td>304</td>
    <td>Not Modified</td>
    <td>Без изменений. Запрашиваемый документ не был изменен с момента последнего запроса</td>
  </tr> 
  <tr>
    <td>306</td>
    <td>Switch Proxy</td>
    <td>Использовавшийся раньше код ответа, в настоящий момент зарезервирован</td>
  </tr>  
  <tr>
    <td>307</td>
    <td>Temporary Redirect</td>
    <td>Временный редирект. Запрашиваемый ресурс на короткое время доступен по другому URL</td>
  </tr> 
  <tr>
    <td>308</td>
    <td>Resume Incomplete</td>
    <td>Перемещено навсегда / возобновление после прерывания. Запрашиваемая страница была перенесена на новый URL на постоянной основе (редирект 308 сохраняет HTTP метод, в отличии от 301-го, где возможно его изменение), либо предлагается возобновить прерванный PUT или POST запрос</td>
  </tr>
  <tr>
    <td colspan="3" align = "center"><b>4xx: Ошибки клиента</b></td>
  </tr> 
  <tr>
    <td>400</td>
    <td>Bad Request</td>
    <td>Некорректный запрос. Запрос не может быть обработан, поскольку содержит синтаксическую ошибку</td>
  </tr>
  <tr>
    <td>401</td>
    <td>Unauthorized</td>
    <td>Не авторизован. Запрос обрабатывается, но доступ к запрашиваемому ресурсу не предоставляется, поскольку клиент не авторизован</td>
  </tr> 
  <tr>
    <td>402</td>
    <td>Payment Required</td>
    <td>Не используется. Зарезервирован для использования в будущем</td>
  </tr> 
  <tr>
    <td>403</td>
    <td>Forbidden</td>
    <td>Запрещено. Сервер понял запрос, но он не выполняет его из-за ограничений прав доступа к указанному ресурсу</td>
  </tr>
  <tr>
    <td>404</td>
    <td>Not Found</td>
    <td>Не найдено. Запрашиваемая страница не найдена. Сервер понял запрос, но не нашёл соответствующего ресурса по указанному URL (Самая распространенная ошибка в Интернете, возникает из-за неправильно указанного URL)</td>
  </tr>
  <tr>
    <td>405</td>
    <td>Method Not Allowed</td>
    <td>Mетод не поддерживается. Запрос был сделан методом, который не поддерживается данным ресурсом</td>
  </tr>
  <tr>
    <td>406</td>
    <td>Not Acceptable</td>
    <td>Не принимается. Сервер может сгенерировать только такой ответ, который клиент не принимает. (например, на другом языке)</td>
  </tr>
  <tr>
    <td>407</td>
    <td>Proxy Authentication Required</td>
    <td>Требуется аутентификация прокси. Ответ аналогичен коду 401 за исключением того, что аутентификация производится для прокси-сервера</td>
  </tr>
  <tr>
    <td>408</td>
    <td>Request Timeout</td>
    <td>Время ожидания истекло. Запрос клиента к серверу занял слишком много времени</td>
  </tr>
  <tr>
    <td>409</td>
    <td>Conflict</td>
    <td>Конфликт. Запрос не может быть обработан по причине конфликта с другим запросом или конфигурацией сервера</td>
  </tr>  
  <tr>
    <td>410</td>
    <td>Gone</td>
    <td>Недоступен. Доступный по указанному URL раньше был доступен, но был удалён или недоступен</td>
  </tr>
  <tr>
    <td>411</td>
    <td>Length Required</td>
    <td>Нужна длина. Длина контента не определена, и сервер не принимает запрос без этого. Повторный запрос должен содержать заголовок ""Content-Length""</td>
  </tr>
  <tr>
    <td>412</td>
    <td>Precondition Failed</td>
    <td>Не выполнено предварительное условие. Предварительное условие, указанное в запросе, не было выполнено</td>
  </tr>
  <tr>
    <td>413</td>
    <td>Request Entity Too Large</td>
    <td>Слишком большой запрос. Размер запроса превышает максимальный размер запроса, принимаемого сервером</td>
  </tr>  
  <tr>
    <td>414</td>
    <td>Request-URI Too Long</td>
    <td>Слишком длинный URI. Серверу не удается обработать запрос по причине длинного URI. Такая ошибка может возникнуть, когда клиент пытается передать длинные параметры через метод GET, а не POST</td>
  </tr>
  <tr>
    <td>415</td>
    <td>Unsupported Media Type</td>
    <td>Неподдерживаемый формат. Формат не поддерживается, и сервер не может принять запрос</td>
  </tr>
  <tr>
    <td>416</td>
    <td>Requested Range Not Satisfiable</td>
    <td>Недопустимый диапазон. Диапазон байтов, запрошенный клиентом, находится за пределами ресурса</td>
  </tr>
  <tr>
    <td>417</td>
    <td>Expectation Failed</td>
    <td>Ожидания не оправдались. Сервер не может удовлетворить требования заголовка Expect, так как поле заголовка не соответствует ожиданиям</td>
  </tr>
  <tr>
    <td colspan="3" align = "center"><b>5xx: Ошибки сервера</b></td>
  </tr>
  <tr>
    <td>500</td>
    <td>Internal Server Error</td>
    <td>Внутренняя ошибка сервера. Любая внутренняя ошибка сервера, которую сервер не может конкретизировать</td>
  </tr>
  <tr>
    <td>501</td>
    <td>Not Implemented</td>
    <td>Не реализовано. Сервер не распознает указанного в запросе метода и не может обработать запрос</td>
  </tr>
  <tr>
    <td>502</td>
    <td>Bad Gateway</td>
    <td>Ошибка шлюза. Сервер, выступая в роли шлюза или прокси-сервера, получил недействительное ответное сообщение от вышестоящего сервера</td>
  </tr>
  <tr>
    <td>503</td>
    <td>Service Unavailable</td>
    <td>Сервис недоступен. Сервер не доступен в данный момент (перегружен, отключен, на техническом обслуживании)</td>
  </tr>
  <tr>
    <td>504</td>
    <td>Gateway Timeout</td>
    <td>Время ожидания ответа шлюзом истекло. Сервер, выступая в роли шлюза или прокси-сервера, не получил ответа от вышестоящего сервера в отведенное время</td>
  </tr>
  <tr>
    <td>505</td>
    <td>HTTP Version Not Supported</td>
    <td>Версия HTTP не поддерживается. Версия протокола HTTP, используемая в запросе, не поддерживается сервером</td>
  </tr>
  <tr>
    <td>511</td>
    <td>Network Authentication Required</td>
    <td>ребуется аутентификация. Для получения доступа к сети, клиент должен пройти аутентификацию. Ошибка генерируется сервером-посредником, к примеру, сервером интернет-провайдера, если нужно ввести пароль для получения доступа к сети через платную точку доступа</td>
  </tr>  
</table>  
</details>
   
<details><summary><b>Работа с сетями</b></summary></br>  
<img width = '500' align ='right' src="https://media.fs.com/images/community/upload/kindEditor/202205/04/osi-and-tcpip-dod-1651635668-kyjUkvqPPo.jpg" />   
  
**Сетевая модель OSI (базовая эталонная модель взаимодействия открытых систем)** — абстрактная сетевая модель для коммуникаций и разработки сетевых протоколов.  
На этапе зарождения компьютерных сетей не было единых стандартов. Каждый разработчик использовал свои наработки, которые не работали с технологиями других. Очевидно, что необходимо было придумывать общее решение. Эту задачу взяла на себя международная организация по стандартизации (ISO — International Organization for Standartization). После изучения и анализа технологий различных разработчиков и вендоров родилась модель OSI, релиз которой состоялся в 1984 году. Модель вобрала в себя и систематизировала все наработки и технические реализации. Проблема ее была только в том, что ее разрабатывали около 7 лет. Пока специалисты спорили, как ее лучше сделать, другие модели модернизировались и набирали обороты. В настоящее время модель OSI не используют. Она применяется только в качестве обучения сетям и на теории объясняет как устроена и работает сеть.  
  
**Сетевая модель OSI**  
 - состоит из 7 уровней  
 - каждый уровень выполняет определенную ему роль и задачи  
 - нельзя перескакивать с уровня на уровень  
 - весь путь должен проходить строго с верхнего на нижний и с нижнего на верхний. Такие процессы получили название инкапсуляция (с верхнего на нижний) и деинкапсуляция (с нижнего на верхний)  
 - на каждом уровне передаваемая информация называется по-разному  
  
**Уровни OSI**  
  
<img width = '700'  align ='center' src="https://learn.trudmore.ru/assets/uploads/2017/08/osi.png" />  
  
**Первый, физический уровень (physical layer, L1)**  
Отвечает за обмен физическими сигналами между физическими устройствами, «железом». Компьютерное железо не понимает, что такое картинка или что на ней изображено, железу картинка понятна только в виде набора нулей и единиц, то есть бит. В данном случае бит является блоком данных протокола, сокращенно PDU (Protocol Data Unit).  
Каждый уровень имеет свои PDU, представляемые в той форме, которая будет понятна на данном уровне и, возможно, на следующем до преобразования. Работа с чистыми данными происходит только на уровнях с пятого по седьмой.  
Устройства физического уровня оперируют битами. Они передаются по проводам (например, через оптоволокно) или без проводов (например, через Bluetooth или IRDA, Wi-Fi, GSM, 4G и так далее).  
  
**Второй уровень, канальный (data link layer, L2)**  
Второй уровень решает проблему адресации при передаче информации. Канальный уровень получает биты и превращает их в кадры (frame, также «фреймы»). Задача здесь — сформировать кадры с адресом отправителя и получателя, после чего отправить их по сети.  
У канального уровня есть два подуровня — это MAC и LLC. MAC (Media Access Control, контроль доступа к среде) отвечает за присвоение физических MAC-адресов, а LLC (Logical Link Control, контроль логической связи) занимается проверкой и исправлением данных, управляет их передачей.  
На втором уровне OSI работают коммутаторы, их задача — передать сформированные кадры от одного устройства к другому, используя в качестве адресов только физические MAC-адреса.  
  
**Третий уровень, сетевой (network layer, L3)**  
На третьем уровне появляется новое понятие — маршрутизация. Для этой задачи были созданы устройства третьего уровня — маршрутизаторы (их еще называют роутерами). Маршрутизаторы получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута от одного устройства к другому с учетом всех потенциальных неполадок в сети.  
На сетевом уровне активно используется протокол ARP (Address Resolution Protocol — протокол определения адреса). С помощью него 64-битные MAC-адреса преобразуются в 32-битные IP-адреса и наоборот, тем самым обеспечивается инкапсуляция и декапсуляция данных.  
  
**Четвертый уровень, транспортный (transport layer, L4)**  
Четвертый уровень — главной задачей является транспортировка пакетов. Естественно, при транспортировке возможны потери, но некоторые типы данных более чувствительны к потерям, чем другие. Например, если в тексте потеряются гласные, то будет сложно понять смысл, а если из видеопотока пропадет пара кадров, то это практически никак не скажется на конечном пользователе. Поэтому, при передаче данных, наиболее чувствительных к потерям на транспортном уровне используется протокол TCP, контролирующий целостность доставленной информации.  
Для мультимедийных файлов небольшие потери не так важны, гораздо критичнее будет задержка. Для передачи таких данных, наиболее чувствительных к задержкам, используется протокол UDP, позволяющий организовать связь без установки соединения.  
При передаче по протоколу TCP, данные делятся на сегменты. Сегмент — это часть пакета. Когда приходит пакет данных, который превышает пропускную способность сети, пакет делится на сегменты допустимого размера. Сегментация пакетов также требуется в ненадежных сетях, когда существует большая вероятность того, что большой пакет будет потерян или отправлен не тому адресату. При передаче данных по протоколу UDP, пакеты данных делятся уже на датаграммы. Датаграмма (datagram) — это тоже часть пакета, но ее нельзя путать с сегментом.  
Первые четыре уровня — специализация сетевых инженеров, но с последними тремя они не так часто сталкиваются, потому что пятым, шестым и седьмым занимаются разработчики.  
  
**Пятый уровень, сеансовый (session layer, L5)**  
Сеансовый уровень отвечает за поддержку сеанса или сессии связи. Пятый уровень оказывает услугу следующему: управляет взаимодействием между приложениями, открывает возможности синхронизации задач, завершения сеанса, обмена информации.  
Службы сеансового уровня зачастую применяются в средах приложений, требующих удаленного вызова процедур, т.е. чтобы запрашивать выполнение действий на удаленных компьютерах или независимых системах на одном устройстве (при наличии нескольких ОС).  
Примером работы пятого уровня может служить видеозвонок по сети. Во время видеосвязи необходимо, чтобы два потока данных (аудио и видео) шли синхронно. Когда к разговору двоих человек прибавится третий — получится уже конференция. Задача пятого уровня — сделать так, чтобы собеседники могли понять, кто сейчас говорит.  
  
**Шестой уровень, представления данных (presentation layer, L6)**  
Шестой уровень занимается тем, что представляет данные (которые все еще являются PDU) в понятном человеку и машине виде. Например, когда одно устройство умеет отображать текст только в кодировке ASCII, а другое только в UTF-8, перевод текста из одной кодировки в другую происходит на шестом уровне.  
Шестой уровень также занимается представлением картинок (в JPEG, GIF и т.д.), а также видео-аудио (в MPEG, QuickTime). Помимо перечисленного, шестой уровень занимается шифрованием данных, когда при передаче их необходимо защитить.  
  
**Седьмой уровень, прикладной (application layer)**  
Прикладной уровень — это то, с чем взаимодействуют пользователи, своего рода графический интерфейс всей модели OSI, с другими он взаимодействует по минимуму.  
Все услуги, получаемые седьмым уровнем от других, используются для доставки данных до пользователя. Протоколам седьмого уровня не требуется обеспечивать маршрутизацию или гарантировать доставку данных, когда об этом уже позаботились предыдущие шесть. Задача седьмого уровня — использовать свои протоколы, чтобы пользователь увидел данные в понятном ему виде.  
Протоколы здесь используют UDP (например, DHCP) или TCP (например, HTTP, HTTPS, SFTP (Simple FTP), DNS). Прикладной уровень является самым верхним по иерархии, но при этом его легче всего объяснить.  

</details>
  
<details><summary><b>Кэш, куки, веб-сокет</b></summary></br> 
  
**Кэшем** называется место на диске или в оперативной памяти, где хранится временная информация. Наиболее распространенный тип кэша — браузерный, он помогает сэкономить трафик и время загрузки страниц (что является важным показателем эффективной работы сайта и положительно сказывается на пользовательском опыте). С помощью технологии кэширования HTML-страниц, изображений и других веб-элементов сайты загружаются значительно быстрее при их повторном посещении. Кэш здесь выступает своеобразным промежуточным буфером. Для отображения веб-страниц браузер обращается к кэшу, а остальное содержимое запрашивает с сервера.  
  
Браузерное кэширование для клиент-серверного приложения схематично можно представить себе так:  
 - Клиент (браузер) отправляет запрос на сервер с целью загрузить определенную веб-страницу  
 - Сервер на своей стороне формирует ответ и возвращает клиенту пакеты данных, содержащих элементы веб-страницы (HTML и CSS файлы, скрипты, мультимедиа и т.д.)  
 - Браузер получает ответ от сервера и отображает страницу, при этом кэшируя некоторые данные  

**Cookie** — это небольшие служебные файлы, которые хранятся на компьютере пользователя. Они содержат данные, относящиеся к пользователю, его предпочтениям и действиям на конкретном сайте: данные для авторизации (логин и пароль), индивидуальные настройки, посещенные страницы, совершенные действия, товары в корзине, дата и время посещения и т.д. Когда пользователь повторно заходит на сайт, браузер отправляет cookie на сервер, чтобы рассказать сайту о предыдущих активностях пользователя. Cookie обладают определенным сроком жизни, по истечении которого они удаляются.  
  
**Зачем нужны cookie?**   
Cookie помогают улучшить пользовательский опыт использования интернет-ресурсов, сделать работу в интернете более комфортной и быстрой.  
Приведем примеры использования:  
 - Аутентификация пользователя: благодаря cookie пользователям не приходится при каждом посещении сайта заново вводить логин и пароль. Нагрузка на сервер несколько снижается (поскольку данные подтягиваются не напрямую с сервера)  
 - Покупки в интернет-магазинах: cookie позволяют запоминать выбранные товары, так, что они сохраняются в корзине, даже если закрыть сайт/приложение  
 - Персональные предпочтения и настройки пользователя: сохранение этих данных помогают не настраивать заново при каждом посещении регион, язык, стиль оформления и т.д.   
В соответствии с Общим регламентом по защите данных (GDPR) веб-сайты должны оповещать пользователей об использовании файлов cookie, как они и делают с помощью всплывающих окон. Отказаться от использования можно (если такая возможность предоставляется), по правилам GDPR доступ к сервису при этом не будет запрещен или ограничен. Однако надо помнить, что в этом случае пользоваться, например, интернет-магазином станет неудобно. 
  
**Разница между куки и кэш**  
 - Cookie хранят данные, относящиеся к пользователю, его предпочтениям, настройкам и действиям на веб-страницах и используются для более комфортного использования интернет-ресурсов. Кэш хранит некоторое содержимое веб-сайта и используется для ускорения доступа к данным, снижения нагрузки на сервер, более быстрой загрузки сайта. 
 - Cookie-файлы весят обычно немного, поскольку представляют собой текстовые документы, в то время как кэш может занимать много места.  
 - Cookie обычно удаляются по истечению срока действия, в то время как кэш хранится на устройстве до тех пор, пока пользователь вручную его не очистит.  
  
**Веб-сокеты (Web Sockets)** — это передовая технология, которая позволяет создавать интерактивное соединение между клиентом (браузером) и сервером для обмена сообщениями в режиме реального времени. Веб-сокеты, в отличие от HTTP, позволяют работать с двунаправленным потоком данных, что делает эту технологию совершенно уникальной.  
  
**WebSocket** особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, чат-приложения, работающие в реальном времени, и т.д.
</details>
  
<details><summary><b>HTML, CSS, JS</b></summary></br> 
   
**HTML** отображает язык разметки гипертекста. «Язык разметки» означает, что HTML использует теги для идентификации различных типов контента и целей, которые каждый преследует на веб-странице.

Для разметки используются **HTML-теги**, также известные как «элементы». Они имеют довольно интуитивные типы: заголовки, теги абзацев, теги изображений и т. д. 
Каждая веб-страница состоит из нескольких тегов HTML, обозначающих определенный тип контента на странице. Каждый тип содержимого на странице «обернут», т. е. окружен тегами. Например, слова, которые вы сейчас читаете, являются частью абзаца. Если кодировать эту страницу с нуля, этот абзац начался бы с тега абзаца открытия: &lt;p&gt;. Часть «тега» обозначается открытыми скобками, а буква «p» сообщает компьютеру, что мы открываем абзац вместо какого-либо другого типа содержимого.  
  
После того, как тег был открыт, все следующее содержимое считается частью этого тега, пока вы не закроете его. Когда абзац заканчивается, нужно ставить тег заключительного абзаца: &lt;/ p&gt;. Обратите внимание, что закрывающие теги выглядят точно так же, как открывающие теги, за исключением того, что после левой угловой скобки есть косая черта. Вот пример:  
  
*&lt;p&gt; Это абзац. &lt;/ p&gt;*
  
Используя HTML, вы можете добавлять заголовки, форматировать абзацы, разрывы строк, создавать списки, выделять текст, создавать специальные символы, вставлять изображения, создавать ссылки, создавать таблицы, управлять некоторым стилем и многое другое.  
  
**CSS** - это каскадные таблицы стилей. Этот язык разметки определяет, как HTML-элементы веб-сайта должны отображаться на интерфейсе страницы.  
Если HTML - это гипсокартон, CSS - это краска.  
  
В то время как HTML является основной структурой сайта, CSS - это то, что дает всему вашему сайту стиль. Цвета, интересные шрифты и фоновые изображения – все это заслуга CSS. Этот язык влияет на все настроение веб-страницы, что делает его невероятно мощным инструментом и важным навыком для веб-разработчиков. Он также позволяет веб-сайтам адаптироваться к различным размерам экрана и типам устройств.  
  
**JavaScript** - это логический язык программирования, который можно использовать для изменения содержимого веб-сайта и заставить его вести себя по-разному в ответ на действия пользователя. Общее использование JavaScript включает в себя окна подтверждения, призывы к действию и добавление новых идентификаторов к существующей информации. Короче говоря, JavaScript - это язык программирования, который позволяет веб-разработчикам создавать интерактивные сайты с динамичными элементами.  
 - Всплывающие окна  
Одним из примеров JavaScript в действии являются окна, которые появляются на вашем экране. Подумайте, как в последний раз, когда вы ввели свою информацию в онлайн-форму, и появилось окно с подтверждением, попросив вас нажать «ОК» или «Отменить», чтобы продолжить. Это стало возможным благодаря JavaScript - в коде вы найдете инструкцию if else, которая говорит компьютеру делать что-то одно, если пользователь нажимает «ОК», и другое дело, если пользователь нажимает «Отмена».  
 - Призыв к действию  
Другим примером JavaScript является призыв к действию (CTA), подобно тем, которые помещаются в сообщения в блоге, которые появляются в нижней правой части экрана. Вот как это выглядит:  
 - Сохранение новой информации  
JavaScript особенно полезен для назначения новых идентификаторов существующим элементам веб-сайта в соответствии с решениями, которые пользователь делает во время посещения страницы. Предположим, вы создаете целевую страницу с формой, которую хотите генерировать, путем сбора информации о посетителе сайта. Возможно, у вас есть «строка» JavaScript, предназначенная для имени пользователя. Эта строка может выглядеть примерно так:  
`function updateFirstname() {`  
`let firstname = prompt('First Name');`  
`}`
  
Затем, после того как посетитель веб-сайта вводит свое имя и любую другую информацию, требуемую на целевой странице и представляет форму, это действие обновляет идентификацию первоначально неопределенного элемента «firstname» в вашем коде.  
 - Безопасность, игры и спецэффекты  
Другие варианты использования JavaScript: создание паролей безопасности, формы проверки, интерактивные игры, анимации и спецэффекты. Он также используется для создания мобильных приложений и создания серверных приложений. Вы можете добавить JavaScript в HTML-документ, добавив эти «скрипты» или фрагменты кода JavaScript в заголовок или тело вашего документа. Программировать – достаточно непросто, но как только вы изучите основы, будет легче освоить более продвинутые языки программирования.  
  
<b>Справочники:</b>
  
<a href="https://www.w3schools.com/html/"><img height = 50 src="https://img.shields.io/badge/-html-05122A?style=for-the-badge&logo=HTML5&logoColor=1572B6" /> </a>
<a href="https://www.w3schools.com/css/"><img height = 50 src= "https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=css3&logoColor=white" /> </a>
<a href="https://www.w3schools.com/js/" target="_blank"><img height = 50 src="https://img.shields.io/badge/javascript%20-%23323330.svg?&style=for-the-badge&logo=javascript&logoColor=%23F7DF1E" /> </a> 
  
</details>
<details><summary><b>Работа с DevTools</b></summary></br> 
  
**Chrome DevTools** — это набор инструментов, встроенных в браузер Google Chrome, для создания и отладки сайтов. С их помощью можно просматривать исходный код сайта, отлаживать работу frontend: HTML, CSS и JavaScript. Также DevTools позволяет проверять сетевой трафик, быстродействие сайта и многое другое.  
  
**Как начать работу с DevTools**  
Инструмент используют инженеры по тестированию, веб-разработчики и другие специалисты. Открыть DevTools из браузера Google Chrome можно тремя способами:  
 - Сочетанием горячих клавиш: для Windows и Linux Ctrl + Shift + I, для macOS cmd + Shift + I  
 - В контекстном меню: на странице в любом месте кликнуть правой кнопкой мыши и выбрать «Просмотреть код». Главное — не путать с «Просмотр кода страницы», эта опция покажет исходный код вне DevTools.  
 - Через меню браузера: в правом верхнем углу нажать на три точки, в меню выбрать раздел «Дополнительные инструменты» и далее «Инструменты разработчика».  
  
**Какие вкладки есть в DevTools**    
<img height = '400' src="https://blog.skillfactory.ru/wp-content/uploads/2021/11/2-3.png" />  
**Elements.** Здесь отображается весь HTML- и CSS-код открытой страницы. На данной вкладке можно просмотреть и внести исправления в файлы CSS и JavaScript, изменить элементы DOM (программного интерфейса (API) для HTML- и XML-документов). Отредактировать HTML-элементы на странице, открытой в браузере, можно, кликнув по нужному элементу правой кнопкой мыши и выбрав пункт Edit as HTML. Изменения можно наблюдать в режиме реального времени. Манипуляции отображаются только в браузере и не видны другим пользователям. Для того чтобы применить исправленное, необходимо поработать с соответствующими файлами на веб-сервере.  
  
<img height = '400' src="https://blog.skillfactory.ru/wp-content/uploads/2021/11/3-4.png" />   
  
**Console.** Консоль позволяет смотреть вывод JavaScript, а также исполнять свой код для тестирования и отладки страницы. Если на открытой странице не подгрузились какие-либо данные, например стили, шрифты или картинки, здесь отобразятся соответствующие ошибки с подробным описанием. Также в консоль можно ввести команду на языке JavaScript, и она выполнится.  
Вкладка Console отображает все ошибки при загрузке страницы  
  
<img height = '400' src="https://blog.skillfactory.ru/wp-content/uploads/2021/11/4-4.png" />   
    
**Sources.** Вкладка отображает загруженные файлы из всех источников, к которым обращался сайт. В большей степени она используется при отладке кода, позволяет увидеть все файлы и просмотреть их содержимое. Sources можно использовать в качестве полноценного редактора кода, получив доступ к локальным файлам через Workspaces.  
  
<img height = '400' src="https://blog.skillfactory.ru/wp-content/uploads/2021/11/5-3.png" />   
      
**Network.** На вкладке отображаются сетевые запросы, который делает сайт. Как правило, ее используют при оптимизации скорости загрузки страницы, а также для мониторинга выполняемых запросов. Запросы к данным представлены в виде таблицы. Сверху расположены инструменты: очистка таблицы, включение и отключение записи запросов и другие. Под таблицей можно увидеть количество запросов, общее время загрузки всех данных, время загрузки DOM и ресурсов, участвующих в отображении текущей страницы.  
  
<img height = '400' src="https://blog.skillfactory.ru/wp-content/uploads/2021/11/7-3.png" />   
        
**Performances.** Вкладка отображает нагрузку, которую создает сайт на компьютер пользователя. Здесь можно увидеть показатели FPS, загрузки CPU и сетевые запросы, необходимые данные и инструменты для повышения производительности страницы. На панели есть таймлайн использования сети, выполнения JavaScript и загрузки памяти. После первого построения таймлайнов можно найти данные о всем жизненном цикле страницы и выполнении кода.  
Также можно посмотреть время исполнения отдельных частей кода и выбрать конкретный период на шкале, чтобы увидеть, какие процессы происходили в этот интервал. Все это позволяет проанализировать каждое событие, которое происходило в момент загрузки или во время взаимодействия с пользователем.  
  
<img height = '400' src="https://blog.skillfactory.ru/wp-content/uploads/2021/11/6-3.png" />   
  
**Memory.** Здесь расположено несколько инструментов, которые помогают отслеживать, какую нагрузку на систему оказывает выполнение кода:  
 - **Heap Snapshot.** С помощью него можно посмотреть, как распределяется память между объектами JavaScript и связанными с ними элементами DOM.  
 - **Allocation instrumentation on timeline.** Этот инструмент используется для устранения утечек памяти. Он показывает, как распределяется память между переменными в коде.  
 - **Allocation sampling.** Профайлер записывает, как распределяется память на отдельные функции JavaScript.  
  
<img height = '400' src="https://blog.skillfactory.ru/wp-content/uploads/2021/11/8-3.png" />   
  
**Application.** Панель, где можно быстро очистить хранилище и кэш, а также управлять базами данных.  
  
<img height = '400' src="https://blog.skillfactory.ru/wp-content/uploads/2021/11/9-3.png" />   
  
**Security.** Отвечает за надежность ресурса. Здесь можно получить информацию о данных протокола и сертификата безопасности, если они есть. Также, если источник небезопасный, узнать, какие именно запросы не защищены. Поэтому этот инструмент, как правило, используется для решения проблем со смешанным контентом и другими подобными задачами.  
  
<img height = '400' src="https://blog.skillfactory.ru/wp-content/uploads/2021/11/10-3.png" />   
  
**Lighthouse.** На этой вкладке можно проверить производительность сайта.  
 1. **Performance.** Позволяет узнать скорость загрузки сайта. Итоговый показатель зависит от времени загрузки интерактивных элементов, шрифтов и прочего контента, а также от времени блокировки и отрисовки стилей.  
 2. **Progressive Web App.** Позволяет проверить, регистрирует ли сайт Service Workers, возможна ли работа сайта офлайн, а также возвращает ошибку 200.
 3. **Best Practices.** Помогает проверить безопасность сайта и узнать, применяются ли современные стандарты веб-разработки. На показатель влияет использование устаревших API, HTTPS, корректность кодировки и многое другое.  
 4. **Accessibility.** Позволяет узнать, насколько удобен сайт, как воспринимается контент и можно ли управлять интерфейсом и передвигаться по сайту без мыши.
 5. **SEO.** Позволяет понять, насколько соблюдаются рекомендации Google по оптимизации сайта. На показатель влияют использование метатегов, наличие alt у изображений, адаптивная верстка и пр.  
</details>
<details><summary><b>Веб-сервисы. Особенности (и отличия) REST и SOAP</b></summary></br> 
  
**Веб-сервисы (или веб-службы)** — это технология, позволяющая системам обмениваться данными друг с другом через сетевое подключение. Обычно веб-сервисы работают поверх протокола HTTP или протокола более высокого уровня. Веб-сервис — просто адрес, ссылка, обращение к которому позволяет получить данные или выполнить действие.  
  
Главное отличие веб-сервиса от других способов передачи данных: стандартизированность. Приняв решение использовать веб-сервисы, можно сразу переходить к структуре данных и доступным функциям. Например, В SOAP (как более строгом протоколе), уже решён вопрос уведомления об ошибках.  
  
Самые известные способы реализации веб-сервисов:  
 - XML-RPC (XML Remote Procedure Call) — протокол удаленного вызова процедур с использованием XML. Прародитель SOAP. Предельно прост в реализации  
 - SOAP (Simple Object Access Protocol) — стандартный протокол по версии W3C. Четко структурирован и задокументирован  
 - JSON-RPC (JSON Remote Procedure Call) — более современный аналог XML-RPC. Основное отличие — данные передаются в формате JSON  
 - REST (Representational State Transfer) — архитектурный стиль взаимодействия компьютерных систем в сети основанный на методах протокола HTTP  
 - специализированные протоколы для конкретного вида задач, такие как GraphQL  
 - менее распространенный, но более эффективный gRPC, передающий данные в бинарном виде и использующий HTTP/2 в качестве транспорта  
  
**REST** — это архитектурный стиль.  
Специфика REST — использование HTTP в качестве транспортного протокола. Он подразумевает наилучшее использование функций, предоставляемых HTTP — методы запросов, заголовки запросов, ответы, заголовки ответов и т. д.  
  
**Преимущества:**
 - простота реализации  
 - экономичность в плане ресурсов  
 - не требует программных надстроек (json_decode есть почти в каждом языке)  
  
**Недостатки:**
 - отсутствие спецификации  
 - неоднозначность методов управления данными  
<img width = '700' src="https://www.intervolga.ru/upload/medialibrary/fe6/fe6bf6d5c55ceeb7705b185e5ed02b4c.png" />
  
**Где REST лучше использовать и почему:**  
1. В сервисах, которые будут использоваться из javascript. Тут и говорить нечего, javascript хорошо работает с json, поэтому именно его и надо предоставлять  
2. В сервисах, которые будут использоваться из языков, в которых нет возможности сгенерировать прокси клиента. Это Objective-C, например. Не нужно парсить вручную SOAP-конверт, это незачем  
3. Когда существуют очень высокие требования к производительности. Это, как правило, очень интенсивно используемые API, вроде Twitter API или Google API  
  
**SOAP** — это формат обмена сообщениями. 
  
**Преимущества:**
 - отраслевой стандарт по версии W3C  
 - наличие строгой спецификации  
 - широкая поддержка в продуктах Microsoft  
 - однозначность  
   
**Недостатки:**  
 - сложность реализации  
 - сложность / ресурсоемкость парсинга XML-данных  
  
Специфика SOAP — это формат обмена данными. С SOAP это всегда SOAP-XML, который представляет собой XML, включающий:  
— *Envelope (конверт)* – корневой элемент, который определяет сообщение и пространство имен, использованное в документе  
— *Header (заголовок)* – содержит атрибуты сообщения, например: информация о безопасности или о сетевой маршрутизации  
— *Body (тело)* – содержит сообщение, которым обмениваются приложения  
— *Fault* – необязательный элемент, который предоставляет информацию об ошибках, которые произошли при обработке сообщений. И запрос, и ответ должны соответствовать структуре SOAP  
 <img width = '700' src="https://www.intervolga.ru/upload/medialibrary/20f/20f87aba3e6cd7ba538301283daee271.png" />
  
SOAP – это целое семейство протоколов и стандартов, откуда напрямую вытекает, что это более тяжеловесный и сложный вариант с точки зрения машинной обработки. Поэтому REST работает быстрее.  
  
**Формат обмена сообщениями**  
 - В SOAP используете формат SOAP XML для запросов и ответов.  
 - В REST такого фиксированного формата нет. Вы можете обмениваться сообщениями на основе XML, JSON или любого другого удобного формата. JSON является самым популярным среди используемых форматов.  
  
**Определения услуг**  
 - SOAP использует WSDL (Web Services Description Language) — язык описания веб-сервисов и доступа к ним, основанный на языке XML.  
 - REST не имеет стандартного языка определения сервиса. Несмотря на то, что WADL был одним из первых предложенных стандартов, он не очень популярен. Более популярно использование Swagger или Open API.  
  
**Простота реализации**  
RESTFful веб-сервисы, как правило, гораздо проще реализовать, чем веб-сервисы на основе SOAP.  
REST обычно использует JSON, который легче анализировать и обрабатывать. В дополнение к этому, REST не требует наличия определения службы для предоставления веб-службы.  
Однако в случае SOAP вам необходимо определить свой сервис с использованием WSDL, и при обработке и анализе сообщений SOAP-XML возникают большие накладные расходы.  
  
**«REST vs SOAP» можно перефразировать в «Простота vs Стандарты»**  
  
Пример: *букмекерская контора заказала сервис для работы с футбольной статистикой. Пользовательский функционал – получить список матчей, получить детали о матче. Для редакторов – редактировать (Create, Edit, Delete) список матчей, редактировать детали матча. Для такой задачи однозначно надо выбирать подход REST и получать бенефиты от его простоты и естественности во взаимодействии с HTTP. Не нужны нам здесь SOAP-конверты, SOAP-главпочтамты и SOAP-авиапочта, которая может использовать любую марку самолета.*  
  
Теперь пример посложнее: *та же букмекерская контора захотела API для ставок на live матчи. Эта процедура включает в себя многочисленные проверки, например, продолжает ли ставка быть актуальной, не изменился ли коэффициент, не превышена ли максимальная сумма ставки для маркета. После этого происходит денежная транзакция, результаты которой записываются в основную и в резервные базы данных. Лишь после этого клиенту приходит ответ об успешности операции. Здесь явно прослеживается ориентация на операции, имеются повышенные требования к безопасности и устойчивости приложения, поэтому целесообразно использовать SOAP.*  
</details>
<details><summary><b>Анализаторы траффика Charles Proxy/Fiddler</b></summary>  
<h3><a href="https://www.charlesproxy.com/download/">Charles</a></h3>  
  
**Плюсы**  
  
 - **Кроссплатформенность.** Есть версии на Mac OS, Windows и Linux. Это очевидное преимущество, если каждый из ваших коллег выбрал себе рабочую ОС по душе, и нужен общий инструмент для тестирования.  
 - **Удобная панель инструментов** с такими функциями как очищение сессии, редактирование и перевыполнение запроса, остановкой перехвата трафика и другими.  
 - **Классификация запросов по хостам.** У сниффера есть экраны Structure и Sequence. На экране Sequence перехваченные запросы отображаются последовательно, а на экране Structure еще и с группировкой по хостам. Для удобства можно настроить фокус на определенный хост. Тогда остальные запросы попадут в группу Other hosts. Этот вариант подойдет, если вы тестируете небольшую группу запросов к одному хосту, а остальные в текущий момент не важны.  
 - **Возможность экспортировать настройки.** Например, можно попросить коллегу экспортировать настройки Charles и загрузить их себе, чтобы не настраивать все опции вручную. Настройки экспортируются в формате xml.  
 - **Возможность просматривать несколько сессий в соседних закладках.** Здесь под «сессией» я подразумеваю один сеанс перехвата трафика. Например, вы воспроизводите сложный баг, и вам нужно повторить его дважды, чтобы сравнить траффик. Тогда можете использовать для каждого повтора отдельную сессию, а затем переключаться между ними.  
 - **Современный интерфейс.** В отличие от Fiddler Classic, у которого интерфейс напоминает десктопные приложения из 2000-х, Charles выглядит актуальнее.  
  
**Минусы**
  
 - **Нет возможности наложить таймаут на запрос.** При тестировании часто требуется проверить, как поведет себя конкретный запрос при задержке ответа и нестабильном интернете. К сожалению, Charles позволяет создать такую задержку только для хоста. Настройка влияет на все запросы указанного хоста, а их может быть очень и очень много. Найти настройку можно так: Proxy — Trottle Settings.  
 - **Нет возможности экспортировать сессию в формате txt или json.** Теперь под «сессией» я подразумеваю запрос и ответ вместе, одним файлом. Charles предлагает форматы chls, csv, trace, har и другие.  
 - **Документация без скриншотов и видео.** У этого сниффера есть документация на официальном сайте, и она целиком состоит из текста. На мой взгляд, документация платного инструмента должна быть как минимум дополнена поясняющими скриншотами, а еще лучше видео.  
 - **Это платный инструмент.** В отличие от Fiddler Classic, у Charles бесплатный только триальный период в 30 дней. Однако, этот минус сомнительный, т.к. хороший инструмент и должен быть платным.  
  
<h3><a href="https://www.telerik.com/fiddler/fiddler-classic">Fiddler Classic</a></h3>   
  
**Плюсы**
  
 - **Удобная подмена ответов.** Чтобы подменить ответ, в Fiddler Classic достаточно перетащить запрос на закладку AutoResponder. Далее можно выбрать вариант ответа в Rule Editor или нажать Edit Response и дать волю фантазии.  
 - **Много функций вынесены на панель инструментов.** На мой взгляд, панель инструментов Fiddler Classic менее удобная, чем у Charles, но разработчики постарались вынести на нее большое количество опций.  
 - **Возможность цветового выделения запросов.** Для наглядности, можно выделить запрос другим цветом. В Charles я не нашла подобной функции.  
 - **Бесплатный инструмент.** Из трех инструментов, которые я сравниваю, только Fiddler Classic абсолютно бесплатно можно скачать с официального сайта.  
 - **Два способа редактирования запросов.** В Fiddler и Charles есть аналогичные способы редактирования запросов.  
 - **Документация.** Просто почитайте ее на официальном сайте.  
  
**Минусы**
  
 - **Только под Windows.** Для других ОС на официальном сайте Fiddler предлагается скачать Fiddler Everywhere.  
 - **Устаревший дизайн интерфейса.** 
 - **Редактирование ответа только в текстовом формате.** В AutoResponder есть встроенный редактор ответа. Если ответ содержит множество вложенных структур и полей, то читать его в текстовом виде крайне неудобно, а редактирование в формате json отсутствует. Также нет поиска по тексту в редакторе, поэтому быстро найти нужное поле не получится. Однако, выход есть — можно использовать отдельный текстовый файл для подмены ответа.  
  
</details>
<details><summary><b>Знание Postman, SoapUI</b></summary></br> 

</details>
<details><summary><b>Идентификация, аутентификация, авторизация</b></summary></br> 
  
**Идентификация** — это процедура распознавания субъекта по его идентификатору (проще говоря, это определение имени, логина или номера)    
Идентификация выполняется при попытке войти в какую-либо систему (например, в операционную систему или в сервис электронной почты)  
  
**Аутентификация** – это процедура проверки подлинности (пользователя проверяют с помощью пароля, письмо проверяют по электронной подписи и т.д.)  
Чтобы определить чью-то подлинность, можно воспользоваться тремя факторами:  
 - Пароль – то, что мы знаем (слово, PIN-код, код для замка, графический ключ)
 - Устройство – то, что мы имеем (пластиковая карта, ключ от замка, USB-ключ)
 - Биометрика – то, что является частью нас (отпечаток пальца, портрет, сетчатка глаза)

    + **Многофакторная аутентификация**  
Представляет собой метод, при котором пользователю для доступа к учетной записи или подтверждения операции с денежными средствами необходимо двумя различными факторами доказать, что именно он владелец учетной записи или что именно он осуществляет вход.  
Среди видов многофакторной аутентификации наиболее распространена двухфакторная аутентификация (2FA — 2-factor authentication) – метод, при котором пользователю для получения доступа необходимо предоставить два разных типа аутентификационных данных, например, что-то известное только пользователю (пароль) и что-то присущее только пользователю (отпечаток пальца).
  
    + **Однофакторная двухэтапная аутентификация**  
Благодаря тому, что смартфоны стали неотъемлемой частью нашей жизни, именно они стали одним из способов подтверждения личности пользователя. Они являются токенами для доступа к различным ресурсам. В этом случае одноразовый пароль генерируется или с помощью специального приложения, или приходит по SMS – это максимально простой для пользователя метод.  
<img width = '800' src="https://safe-surf.ru/upload/medialibrary/813/autent.png" />  
    
**Авторизация** – это предоставление доступа к какому-либо ресурсу  
    
Пример: *пользователь хочет войти в свой аккаунт Google (Google подходит лучше всего, потому что там процедура входа явным образом разбита на несколько простейших этапов)*   
 - Сачала система запрашивает логин, пользователь его указывает, система распознает его как существующий — это **идентификация**. После этого Google просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь действительно настоящий, ведь пароль совпал, — это **аутентификация**  
 - Возможно, Google дополнительно спросит еще и одноразовый код из SMS или приложения. Если пользователь и его правильно введет, то система окончательно согласится с тем, что он настоящий владелец аккаунта, — это **двухфакторная аутентификация**  
 - После этого система предоставит пользователю право читать письма в его почтовом ящике и все остальное — это **авторизация**  
  
</details>
<details><summary><b>Виды авторизация</b></summary></br> 
  
**Виды режимов авторизации**  
Для удобства пользователей, для использования имеющейся в наличии аппаратуры и для обеспечения выполнения требований безопасности, созданы различные виды режимов авторизации. Часто используется комбинация нескольких таких режимов. Различают такие их типы:  
 - по способу доступа: онлайн и офлайн  
 - по методу разграничения прав: дискреционное, мандатное, на основе ролей, контекста или решетки  
 - по типу кода: логин-пароль, биометрическая, электронный ключ, IP-адрес, динамический пароль, уникальный предмет (пропуск. карта)  
 - по количеству проверок: одно- и многоступенчатая  
  
Существует несколько моделей авторизации. Три основные — ролевая, избирательная и мандатная.  
  
1. **Ролевая модель.** Администратор назначает пользователю одну или несколько ролей, а уже им выдает разрешения и привилегии. Эта модель применяется во многих прикладных программах и операционных системах. 
Например, все пользователи с ролью «Кассир» имеют доступ к кассовым операциям в бухгалтерской системе, а пользователи с ролью «Товаровед» — нет, зато у них есть доступ к складским операциям, при этом обе роли имеют доступ к общей ленте новостей.  
  
2. **Избирательная модель.** Права доступа к конкретному объекту выдают конкретному пользователю. При этом право определять уровень доступа имеет либо владелец конкретного объекта (например, его создатель), либо суперпользователь (по сути, владелец всех объектов в системе). Кроме того, пользователь, обладающий определенным уровнем доступа, может передавать назначенные ему права другим.  
Например, пользователь А, создав текстовый файл, может назначить пользователю Б права на чтение этого файла, а пользователю В — права на его чтение и изменение. При этом пользователи Б и В могут передать свои права пользователю Г.  
Избирательная модель применяется в некоторых операционных системах, например в семействах Windows NT (в том числе в Windows 10) и Unix. По этой же модели предоставляется доступ, скажем, к документам на диске Google.  
  
3. **Мандатная модель.** Администратор назначает каждому элементу системы определенный уровень конфиденциальности. Пользователи получают уровень доступа, определяющий, с какими объектами они могут работать. Обычно такая модель является иерархической, то есть высокий уровень доступа включает в себя права на работу и со всеми младшими уровнями. Мандатная модель авторизации применяется в системах, ориентированных на безопасность, и чаще всего она используется для организации доступа к гостайне и в силовых ведомствах.  
Например, в организации может быть пять уровней доступа. Пользователь, имеющий доступ к файлам 3-го уровня, может также открывать файлы 1-го и 2-го уровня, но не может работать с файлами 4-го и 5-го уровня.  
 
</details>
<details><summary><b>Тестирование веб форм и веб элементов</b></summary></br> 

</details> 
<details><summary><b>Анализ логов (Kibana, Elasticsearch)</b></summary></br> 

</details>
