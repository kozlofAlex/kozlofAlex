<h1 align="center"> Теория тестирования</h1>
<details><summary><b>Основные понятия</b></summary></br> 
  
**Тестирование программного обеспечения (Software Testing)** — проверка соответствия реальных и ожидаемых результатов поведения программы, 
проводимая на конечном наборе тестов, выбранном определённым образом.</br> 
  
**Цель тестирования** — проверка соответствия ПО предъявляемым требованиям, убедиться что качество ПО соответствует ожиданиям и требованиям заказчика, 
предоставить актуальную информацию о состоянии продукта на текущий момент, поиск очевидных ошибок в программном обеспечении, 
которые должны быть выявлены до того, как их обнаружат пользователи программы.</br>  
  
**Для чего проводится тестирование ПО?**
<li>Для проверки соответствия требованиям.</li>  
<li>Для обнаружения проблем на более ранних этапах разработки и предотвращение повышения стоимости продукта.</li>  
<li>Обнаружение вариантов использования, которые не были предусмотрены при разработке. А также взгляд на продукт со стороны пользователя.</li>  
<li>Повышение лояльности к компании и продукту, т.к. любой обнаруженный дефект негативно влияет на доверие пользователей.</li><br />

**Качество ПО** – комплекс характеристик программного продукта, определяющих способность выполнять возложенные на него функции.  

**ПАРАМЕТРЫ КАЧЕСТВА ПО:**  

 1. **Функциональность.** ПО признается функциональным, если выполняет возложенные на него задачи, отвечает заданным потребностям пользователей. 
Данный аспект предполагает правильную и точную работу, совместимость всех входящих в состав компонентов.
 2. **Надежность.** Под надежностью ПО понимают бесперебойное выполнение возлагаемых на него задач на заданных условиях в течение установленного времени.
 3. **Юзабилити (удобство использования).** Этот параметр характеризует степень удобства ПО для пользователей, его наглядность, легкость эксплуатации и изучения.
 4. **Эффективность.** Параметру соответствует степень обеспечения продуктом необходимой производительности при заданных условиях.
 5. **Удобство сопровождения.** Этот показатель характеризует простоту анализа, тестирования, коррекции компонентов ПО, его обслуживания, 
а также степень адаптации к новым условиям.
 6. **Портативность.** Степень легкости его переноса на другую платформу. Обеспечение качества ПО предполагает его проверку по каждому из перечисленных 
параметров, выявление слабых сторон и устранение неисправностей.
 7. **Совместимость.** Способность программных компонентов взаимодействовать друг с другом.
 8. **Защищенность.**, т.е. минимизация угроз, связанных с несанкционированным чтением, изменением информации и т. д. Угрозы могут быть также связаны с 
некорректным использованием ПО, внешним воздействием со стороны посторонних лиц, выходом из строя технических средств.
</details>

<details> <summary><b>Обязанности тестировщика</b></summary> </br>
  
**Контроль и поиск проблем**  
В первую очередь, специалист должен контролировать качество разрабатываемых продуктов и анализировать ошибки, 
которые могут возникнуть у конечных потребителей при их использовании.  
**Тестирование**  
Следующий этап – это разработка тестовых наборов и их регулярный прогон, подготовка тестовых данных, 
написание методики тестирования.  
**Анализ**  
Данные, полученные в процессе проверок, анализируются. Обнаруженные недочеты классифицируются и заносятся в базу.  
**Саппорт**  
Тестировщик не устраняет найденные проблемы и недочеты. Он регулирует и поддерживает процесс их ликвидации – 
находит недочеты и сообщает о них тем специалистам, которые занимаются их исправлением (например, разработчикам), 
а также дополняет необходимой информацией о дефекте, если такая требуется.  
**Документирование дефектов**  
Чтобы провести тестирование, зафиксировать его результаты, тестировщик должен корректно внести информацию в 
техническую документацию. Рекомендуется проверять документы на предмет полноты и актуальности данных.  
  
**Hard skills – технические навыки.**
 - Знание OC на уровне продвинутого пользователя
 - Английский язык
 - Знание языки программирования
 - Знание веб-технологий, мобильных приложений, геймдева и т.д
 - Умение гуглить

**Soft skills – личностные характеристики.**
 - Внимательность
 - Усидчивость
 - Обучаемость
 - Коммуникабельность
 - Ответственность
</details>

<details> <summary><b>Принципы тестирования</b></summary></br>
  
 1. **Тестирование демонстрирует наличие дефектов**  
Тестирование только снижает вероятность наличия дефектов, которые находятся в программном обеспечении, 
но не гарантирует их отсутствия.  
 2. **Исчерпывающее тестирование невозможно**  
Полное тестирование с использованием всех входных комбинаций данных, результатов и предусловий физически невыполнимо 
(исключение — тривиальные случаи). 
Задача тестировщика — с минимальными усилиями покрыть как можно больше тестовых случаев и функциональности.  
 3. **Раннее тестирование**  
Следует начинать тестирование на ранних стадиях жизненного цикла разработки ПО, чтобы найти дефекты как можно раньше.  
 4. **Скопление дефектов**  
Большая часть дефектов находится в ограниченном количестве модулей. К этому принципу применим Закон Парето 
(20 % усилий дают 80 % результата, а остальные 80 % усилий — лишь 20 % результата), 80% дефектов находятся в 20% функций. 
Тестировщик должен распределять свои усилия пропорционально фактической плотности дефектов. 
 5. **Парадокс пестицида**  
Если повторять те же тестовые сценарии снова и снова, в какой-то момент этот набор тестов перестанет выявлять новые дефекты. 
ПО все время эволюционирует и многие из ранее найденных дефектов исправляют и старые тесты больше не срабатывают. 
Способы решения:  
  + Что бы преодолеть этот парадокс необходимо периодически вносить изменения в используемые наборы тестов и корректировать 
их для того, чтобы они отвечали новому состоянию системы.    
  + Постоянно изучать новые методы тестирования и внедрять их в свою работу.  
  + Давать прогонять тесты другим участникам команды, что бы разные тестировщики в разное время тестировали одну и туже функциональность.    
 6. **Тестирование зависит от контекста**  
Тестирование проводится по-разному в зависимости от контекста. Выбор методологии, техники или типа тестирования будет напрямую 
зависеть от природы самой программы. Например, программное обеспечение, в котором критически важна безопасность, тестируется 
иначе, чем новостной портал. Или ПО для медицины требует более тщательной проверки чем компьютерная игра. 
Или сайт с большей посещаемостью должен пройти через серьезное тестирование производительности что бы показать 
возможность работы в условии высокой нагрузки.  
  7. **Заблуждение об отсутствии ошибок**  
Отсутствие найденных дефектов при тестировании не всегда означает готовность продукта к релизу. Нахождение и исправление дефектов 
будет не важны если система окажется неудобной в использовании и не будет удовлетворять нужды пользователей.  
</details>

<details> <summary><b>Отличия QA и QC и Testing</b></summary></br>  
  
**Testing** – проверка создаваемого продукта на соответствия требованиям к этому продукту. По факту это реактивная рутинная работа.  

**QC (Quality Control)** — Контроль качества продукта — анализ результатов тестирования и качества новых версий выпускаемого продукта.  
  
К задачам контроля качества относятся:  
 - проверка готовности ПО к релизу  
 - проверка соответствия требований  
 - предоставление объективной картины качества проекта.  
  
**QA (Quality Assurance)** — Обеспечение качества продукта — изучение возможностей по изменению и улучшению процесса разработки, 
улучшению коммуникаций в команде, где тестирование является только одним из аспектов обеспечения качества.
Проводит мероприятия на всех этапах разработки. Проактивная работа: основная задача QA это выстроить систему, которая будет 
превентивно работать на качество продукта, то есть предупреждать какие-то дефекты, наладить процесс так что бы эти дефекты 
были обнаружены как можно раньше.  
  
К задачам обеспечения качества относятся:  
 - проверка технических характеристик и требований к ПО  
 - оценка рисков  
 - планирование задач для улучшения качества продукции  
 - подготовка документации, тестового окружения и данных  
 - тестирование  
 - анализ результатов тестирования, а также составление отчетов и других документов  
  
*На примере создания автомобиля*: testing и qc может определить работают ли все детали, и сама машина так как мы ожидаем из 
правильных ли материалов она сделана, то есть подразумевается, что тестированный объект уже существует и готов к проверке. 
Задачей же qa является обеспечение соответствия всех этапов в конструировании машины определенным стандартам качества 
начиная с планирования и создания чертежей и заканчивая сборкой уже готового автомобиля, то есть качеству объекта уделяется 
внимание еще до того, как сам объект был создан.  
</details>

<details> <summary><b>Верификация и валидация</b></summary></br>  
  
**Верификация (verification)** — это процесс проверки разрабатываемого ПО его требованиям (спецификации). 
Верификация — это статическая проверка, то есть происходит без запуска кода и отвечает на вопрос 
«Делаем ли мы продукт правильно?».  
Происходит всегда до валидации.  
  
**Валидация (validation)** — это процесс проверки разрабатываемого ПО ожиданиям и потребностям пользователя. 
Валидация — это динамическая проверка, то есть происходит с запуском кода и отвечает на вопрос 
«Делаем ли мы правильный продукт?».  
Происходит всегда после верификации.  
  
*На примере создания автомобиля*: верификация покажет выполнен ли автомобиль из соответствующих материалов, 
установлен ли заявленный двигатель, верны ли габариты, то есть все то, что было прописано в спецификации. 
Валидация же покажет поедет ли автомобиль вообще, удобно ли выполнены сиденья, поместится ли в багажник 
большой чемодан, то есть насколько продукт отвечает нуждам.  
  
*На примере формы для авторизации в системе*: верификация – проверяем размеры полей, которые прописаны в спецификации. 
Валидация - если оставить поле с логином пустым и нажать на кнопку «Войти», то система сообщит об ошибке.  
</details>

<details><summary><b>Уровни тестирования</b></summary></br>    
  
Тестирование на разных уровнях производится на протяжении всего жизненного цикла разработки и сопровождения ПО. 
Уровень тестирования определяет то, над чем производятся тесты: над отдельным модулем, группой модулей или системой, в целом.  
  
1. **Компонентное (модульное) тестирование**  
Обычно unit тестированием занимается разработчик программного кода, так как именно unit тесты позволяют протестировать 
отдельные компоненты исходного кода программы. Юнит-тест (unit test), или модульный тест, — это программа, которая проверяет работу
небольшой части кода.  На примере интернет-магазина к таким модулям можно отнести: страницу авторизации, поиск товара, перемещение
товара в корзину, оплата заказа.  
2. **Интеграционное тестирование**  
Тестирование части системы, состоящей из двух и более модулей. Интеграционное тестирование предназначено для проверки 
связи между компонентами, а также взаимодействия с различными частями системы (операционной системой, оборудованием 
либо связи между различными системами). Например: как можно со страницы корзины произвести оплату посредство платежной системы.  
   - *Компонентный интеграционный уровень* - проверяется взаимодействие отдельных модулей одного приложения.  
   - *Системный интеграционный уровень* – тестирование взаимодействия между всеми компонентами одной системы или 
взаимодействие между разными системами или тестирование интерфейсов, с помощью которых взаимодействует система.  
  
Существует 3 вида интерфейсов:  
   - **API (программный интерфейс приложения)** – набор методов который можно использовать для доступа к функциональности 
другой программы. Например: платежные системы, взаимодействия с социальными сетями.  
   - **CLI (интерфейс командной строки)** - инструкции компьютеру даются в основном путём ввода с клавиатуры текстовых строк. 
Командная строка в системе windows.  
   - **GUI (Графический интерфейс пользователя)** – программные функции представлены графическими элементами экрана. 
То, что видим в окне браузера, когда открываем страницу в интернете.  
  
3. **Системное тестирование** – тестирование, которое выполняется на полной интегрированной системе, с целью проверки 
системе исходным требованиям. При этом выявляются дефекты, такие как неверное использование ресурсов системы, 
несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, 
неудобство использования и т.д.  
  
4. **Приемочное тестирование** - процесс тестирования, который проверяет соответствие системы требованиям и проводится 
с целью определения удовлетворяет ли система приемочным критериям, а также для вынесения решения заказчиком принимается 
приложение или нет. По сути, это финальный этап тестирования продукта перед его релизом.  
  
Типы приемочного тестирования:  
   - Пользовательское приемочное тестирование – проводится пользователями конечного продукта.
   - На соответствие контракту
   - Альфа тестирование – тестирование на стороне разработчика.
   - Бета тестирование – тестирование на внешней стороне и без участия разработчиков
</details>

<details> <summary><b>Жизненный цикл тестирования (STLC)</b></summary></br>  
  
**STLC, или жизненный цикл тестирования** — это последовательность действий, проводимых в процессе тестирования, 
с помощью которых гарантируется качество программного обеспечения и его соответствие требованиям.  
  
**Этапы STLC-цикла:**  
  
1. **Анализ требований**  
На этом этапе отдел QA оценивает требования с точки зрения тестирования, ищет требования к софту, которые нужно 
предварительно оценить. Для этого QA-команда может обращаться к представителям заказчика. Требования могут быть 
«функциональными» или «нефункциональными», то есть касаться или не касаться функциональной составляющей софта. 
Также на этом этапе проводится оценка возможности применения автоматизированного тестирования.
Действия на этапе оценки требований:  
   - Определение типов тестирования  
   - Сбор информации о приоритетах в тестировании  
   - Подготовка матрицы отслеживания требований (RTM — Requirement Traceability Matrix)  
   - Определение тестового окружения  
   - Анализ возможности автоматизации тестирования  
  
2. **Планирование тестирования**  
На этапе планирования руководитель команды QA определяет стратегию тестирования и оценивает трудозатраты. 
Также оцениваются ресурсы, тестовое окружение, возможные ограничения и график тестирования. 
На этом же этапе готовится и финализируется план тестирования.  
Действия на этапе планирования:  
   - Подготовка стратегии (или плана тестирования)  
   - Выбор инструментов тестирования  
   - Оценка трудозатрат  
   - Планирование ресурсов, определение ролей и ответственности  
   - Дополнительное обучение команды  
  
3. **Создание тест-кейсов**  
На этом этапе происходит подготовка тестовых данных и создаются тест-кейсы.  
Действия:
   - Создание тест-кейсов (и автотестов, если будет применяться автоматизация)  
   - Подготовка исходных данных для тестирования  
  
4. **Настройка тестового окружения**  
Это настройка харда и софта, в которых будет осуществляться процесс тестирования. 
Это один из критически важных аспектов процесса, он может проходить параллельно этапу создания тест-кейсов. 
QA-команда может и не включаться в этот процесс, если тестовое окружение ей обеспечит команда разработки. 
QA-команда должна будет проверить работоспособность окружения (хотя бы smoke-тестом).  
Действия:  
   - Понять нужную архитектуру, настройки окружения и подготовить список требований к харду и софту  
   - Настроить тестовое окружение и тестовые данные  
   - Провести smoke-тест окружения  
  
5. **Выполнение тестирования**  
На этапе выполнения тестов QA проводит тестирование, выполняя подготовленные тест-кейсы. 
Процесс состоит из выполнения тестовых скриптов (при необходимости эти скрипты могут корректироваться). 
Далее идет создание баг-репортов. Если найдены баги, информация о них передается команде разработки для исправления 
и повторного тестирования QA-командой.  
Действия:  
   - Выполнение тестирования в соответствии с планом  
   - Получение результаты тестирования  
   - Обновление RTM-матрицы (тест-кейсы из RTM-матрицы связываются с найденными багами)  
   - Повторное тестирование исправленных багов  
  
6. **Завершение цикла тестирования**  
На этапе завершения тестирования создается отчет о результатах тестирования. 
QA-команда обсуждает и анализирует баги, делает выводы из возникших проблем, чтобы избежать 
подобных проблем в будущем.  
Действия:  
   - Оценка критериев завершения цикла (основывается на времени, трудозатратах, покрытии тестами)  
   - Подготовка документа с выводами, сделанными во время тестирования  
   - Подготовка отчета о завершении тестирования  
   - Подготовка отчета для клиента с количественными и качественными характеристиками тестируемой системы  
   - Анализ результатов тестирования  
</details>

<details> <summary><b>Жизненный цикл ПО (SDLC)</b></summary></br>     
  
**Стадии разработки ПО** — этапы, которые проходят команды разработчиков ПО, прежде чем программа станет доступной для широкого круга пользователей.  
  
Программный продукт проходит следующие стадии:  
1. **Анализ требований**  
 - Заказчик продукта отвечает на вопрос «Что нужно сделать?», а руководитель проекта – на вопрос «Как это сделать». 
 - Здесь также может принимать участие и бизнес-аналитик, чтобы понять потребности и перевести их в бизнес-требования.
 - Определение и документирование требований в виде ТЗ на разработку ПО и/или спецификации  
2. **Планирование**  
На этом этапе ищем ответ на следующий вопрос: «Что вы хотите сделать?» Этот вопрос может вдохновить вас на понимание юнит-экономики вашего плана 
(затраты и выгоды), факторов снижения рисков и ожидаемых стоимостей.  
3. **Проектирование и дизайн**  
Определение дизайна и архитектуры ПО, а также другие особенности реализации, например, UI/UX-дизайн (ИТ-архитектор, дизайнер, системный аналитик).  
4. **Разработка ПО**  
Непосредственная реализация всех запланированных требований, что делают программисты/разработчики ПО.  
5. **Тестирование**  
По завершению этого этапа вы должны будете в состоянии обеспечить рабочее состояние продукта. 
Отслеживайте ошибки и неточности, выслушивайте чужие точки зрения, и глубоко погружайтесь в вопрос с целью поиска тормозящих выход финального 
продукта ошибок.  
6. **Развертывание и сопровождение**  
Регулирует использование финального продукта.  
</details>  

<details> <summary><b>Модели разработки ПО</b></summary></br>  
  
**Модели разработки ПО**  
1. **Каскадная методология (WATERFALL MODEL)**  
Суть модели в том, что каждая стадия проводится один раз, одна за другой. Чтобы приступить к следующей фазе, нужно полностью закончить предыдущую.  
  
*Преимущества:*  
  - Все фазы проекта строго регламентированы и выполняются в четкой последовательности (***Полное документирование***)  
  - Требования к проекту не изменяются на протяжении всего цикла (***Прозрачность***)  
  - Строго фиксированное выполнение всех стадий проекта позволяет планировать ресурсы и сроки завершения работ (***Четкое планирование***)  
  
*Недостатки:*  
  - Тестирование осуществляется с середины проекта (***Раннее тестирование***)  
  - Поскольку требования неизменны и должны быть четко сформулированы, часто возникают сложности при их написании (***Избыточное документирование***)  
  - Пользователь не может убедиться в качестве продукта до полного завершения его разработки (***Отсутствие гибкости***)  
  
2. **V-ОБРАЗНАЯ МЕТОДОЛОГИЯ (V-MODEL)**  
Эта модель – своего рода доработанная версия каскадной методологии, поскольку она помогает избавиться от недостатков, проявляемых ранее.
Ее суть – полный контроль над процессами на всех стадиях разработки с целью убедится в том, что уже можно переходить на следующую ступень. 
Тестирование начинается еще на стадии формулировки требований.  
  
*Преимущества:*  
   - Возможность промежуточного тестирования  
   - Строго регламентированные этапы  
   - Низкий уровень риска и избавление от потенциально возможных багов еще на начальных этапах благодаря раннему тестированию  
  
*Недостатки:*  
   - Невозможность адаптации к новым требованиям заказчика (отсутствие гибкости)  
   - Процесс разработки длиться долго (иногда даже годами). Как результат, продукт теряет свою актуальность для заказчика  
  
3. **СПИРАЛЬНАЯ (итерационная) МЕТОДОЛОГИЯ (SPIRAL MODEL)**  
В данной модели жизненный цикл ПО изображен в виде спирали. Она начинается на стадии написания плана и создает так называемые витки по выполнению 
каждого следующего этапа.Таким образом, по окончанию каждого витка мы получаем целостный прототип, прошедший тестирование и дополняющий всю сборку. 
Если этот прототип отвечает всем предъявленным требованиям, он считается готовым к выпуску. 
  
*Преимущества:*  
   - Гибкость проектирования  
   - Достаточно внимания уделено процессу руководства рисками  
   - Новый функционал можно добавить на поздней стадии разработки  
  
*Недостатки:*  
   - Не всегда все требования известны к началу проектирования  
   - Оценка рисков на каждой стадии влечет за собой достаточно большие затраты  
   - Возможность постоянно оставлять отзывы заказчиком провоцирует обновленные итерации, что влияет на сроки разработки ПО  
  
4. **Agile (идеология)** — манифест разработки программного обеспечения  
Мы постоянно открываем для себя более совершенные методы разработки программного обеспечения, занимаясь разработкой непосредственно и помогая 
в этом другим. Благодаря проделанной работе мы смогли осознать, что:  
    1. Люди и взаимодействие важнее процессов и инструментов  
    2. Работающий продукт важнее исчерпывающей документации  
    3. Сотрудничество с заказчиком важнее согласования условий контракта  
    4. Готовность к изменениям важнее следования первоначальному плану  
  
Основополагающие **принципы Agile-манифеста:**  
1. Наивысшим приоритетом для нас является удовлетворение потребностей заказчика благодаря регулярной и ранней поставке ценного программного обеспечения  
2. Изменение требований приветствуется даже на поздних стадиях разработки. Agile-процессы позволяют использовать изменения для обеспечения заказчику 
конкурентного преимущества  
3. Работающий продукт следует выпускать как можно чаще, с периодичностью от пары недель до пары месяцев  
4. На протяжении всего проекта разработчики и представители бизнеса должны ежедневно работать вместе  
5. Над проектом должны работать мотивированные профессионалы. Чтобы работа была сделана, создайте условия, обеспечьте поддержку и полностью 
доверьтесь им  
6. Непосредственное общение является наиболее практичным и эффективным способом обмена информацией как с самой командой, так и внутри команды  
7. Работающий продукт — основной показатель прогресса  
8. Инвесторы, разработчики и пользователи должны иметь возможность поддерживать постоянный ритм бесконечно. Agile помогает наладить такой
устойчивый процесс разработки  
9. Постоянное внимание к техническому совершенству и качеству проектирования повышает гибкость проекта  
10. Простота — искусство минимизации лишней работы — крайне необходима  
11. Самые лучшие требования, архитектурные и технические решения рождаются у самоорганизующихся команд  
12. Команда должна систематически анализировать возможные способы улучшения эффективности и соответственно корректировать стиль своей работы  
</details>  

<details><summary><b>SCRUM</b></summary></br>  
  
**Scrum** можно определить так — это методология управления проектами, которая построена на принципах тайм-менеджмента. 
Основной ее особенностью является вовлеченность в процесс всех участников, причем у каждого участника есть своя определенная роль. 
Суть в том, что не только команда работает над решением задачи, но все те, кому интересно решение задачи. Не просто поставили задачу 
и расслабились, а постоянно «работают» с командой и эта работа не означает только постоянный контроль.  
  
Основные термины, которые используются в методологии:  
  
**Владелец продукта (Product owner)** — человек, который имеет непосредственный интерес в качественном конечном продукте, он понимает, как это продукт 
должен выглядеть/работать. Этот человек не работает в команде, он работает на стороне заказчика/клиента (это может быть как другая компания, так и 
другой отдел), но этот человек работает с командой. И это тот человек, который расставляет приоритеты для задач.  
**Scrum-мастер** — это человек, которого можно назвать руководителем проекта, хотя это не совсем так. Главное, что это человек «зараженный Scrum-бациллой» 
настолько, что несет ее как своей команде, так и заказчику и, соответственно, следит за тем, чтобы все принципы Scrum соблюдались.
Scrum-команда — это команда, которая принимает все принципы Scrum и готова с ними работать.
Спринт — отрезок времени, который берется для выполнения определенного (ограниченного) списка задач. Рекомендуется брать 2-4 недели (длительность 
определяется командой один раз).  
**Бэклог (backlog)** — это список всех работ. Можно сказать, это ежедневник общего пользования. Различают 2 вида бэклогов: Product-бэклог и спринт-бэклог.
  - ***Product-бэклог*** — это полный список всех работ, при реализации которых мы получим конечный продукт.  
  - ***Спринт-бэклог*** — это список работ, который определила команда и согласовала с Владельцем продукта на ближайший отчетный период (спринт).  
Задания в спринт-бэклог берутся из product-бэклога. 
  
**Планирование спринта** — это совещание, на котором присутствуют все (команда, Scrum-мастер, Владелец продукта). В течение этого совещания Владелец 
продукта определяет приоритеты заданий, которые он хотел бы увидеть выполненными по истечении спринта. Команда оценивает по времени, сколько из 
желаемого они могут выполнить. В итоге получается список заданий, который не может меняться в течение спринта и к концу спринта должен быть 
полностью выполнен.  
</details>

<details><summary><b>Требования и их анализ</b></summary></br>  
  
**Требования** — это спецификация (описание) того, что должно быть реализовано.
Требования описывают то, что необходимо реализовать, без детализации технической стороны решения.  
  
Атрибуты требований:  
 1. **Корректность** — точное описание разрабатываемого функционала.
 2. **Проверяемость** — способ однозначной проверки выполнено требование или нет.  
 3. **Полнота** — в требовании должна содержаться вся необходимая для реализации функциональности информация.  
В условиях массового интернет-мошенничества с кредитными картами дополнительной степенью защиты является CVV2 
номер, идущий за номером карты на обратной ее стороне (на полоске с подписью). Продюсер по незнанию или по халатности может не 
предусмотреть в опеке, что пользователь должен ввести CVV2 при регистрации карты, что в итоге приведет к большему
числу мошеннических транзакций.  
 4. **Недвусмысленность** — требование должно содержать однозначные формулировки. 
«Отчет должен загружаться быстро» → что значит «быстро»?
пользователь будет уверен, что страница будет грузиться доли секунды, даже если это сложный отчет на многомиллионных данных;
разработчик прикинет, что в таких объемах 5 секунд нормальное время отклика, даже быстрое.
Отчет за год должен загружаться не более секунды.  
 5. **Непротиворечивость** — требование не должно содержать внутренних противоречий и противоречий другим требованиям и документам.
Например, есть страница нефункциональных требований, где написано, что любая страница должна грузится не более 3 секунд.
Аналитик пишет ТЗ на новый модуль отчетности, который использует много данных и сложные формулы. И он пишет, что отчет может грузиться 
вплоть до минуты. Явное противоречие!  
 6. **Приоритетность** — у каждого требования должен быть приоритет (количественная оценка степени значимости требования).
 Этот атрибут позволит грамотно управлять ресурсами на проекте.  
 7. **Атомарность** — требование нельзя разбить на отдельные части без потери деталей.  
 8. **Модифицируемость** — в каждое требование можно внести изменение.  
 9. **Прослеживаемость** — каждое требование должно иметь уникальный идентификатор, по которому на него можно сослаться.  
 10. **Осуществимость** — этот пункт обычно проверяют разработчики. Они остужают буйные фантазии из серии «загружать миллионы данных 
за 0,1 секунду» или что-то архитектурно сложное. Бывает такое, что на бумаге всё звучит просто, а вот сделать это займет человеко-месяц в лучшем случае.  
</details>
  
<details><summary><b>Отчёт о дефекте</b></summary></br> 
  
**Дефект (bug)** — отклонение фактического результата от ожидаемого.  
  
**Отчёт о дефекте (bug report)** — документ, который содержит отчет о любом недостатке в компоненте или системе, 
который потенциально может привести компонент или систему к невозможности выполнить требуемую функцию.  
Самые популярные  бак трэкинговые системы: JIRA, Trello, Azure DevOps, Redmine, Яндекс Трекер, Mantis, Bugzilla, Youtrack  
  
Атрибуты отчета о дефекте:  
 - ***Уникальный идентификатор (ID)*** — присваивается автоматически системой при создании баг-репорта.  
 - ***Тема (краткое описание, Summary)*** — кратко сформулированный смысл дефекта, отвечающий на вопросы: Что? Где? Когда (при каких условиях)?  
 - ***Подробное описание (Description)*** — более широкое описание дефекта (указывается опционально).  
 - ***Шаги для воспроизведения (Steps To Reproduce)*** — описание четкой последовательности действий, которая привела к выявлению дефекта. В шагах воспроизведения должен быть описан каждый шаг, вплоть до конкретных вводимых значений, если они играют роль в воспроизведении дефекта.  
 - ***Фактический результат (Actual result)*** — описывается поведение системы на момент обнаружения дефекта в ней. чаще всего, 
содержит краткое описание некорректного поведения (может совпадать с темой отчета о дефекте).  
 - ***Ожидаемый результат (Expected result)*** — описание того, как именно должна работать система в соответствии с документацией.  
 - ***Вложения (Attachments)*** — скриншоты, видео или лог-файлы.  
 - ***Серьёзность дефекта (важность, Severity)*** — характеризует влияние дефекта на работоспособность приложения.  
 - ***Приоритет дефекта (срочность, Priority)*** — указывает на очерёдность выполнения задачи или устранения дефекта.  
 - ***Статус (Status)*** — определяет текущее состояние дефекта. Статусы дефектов могут быть разными в разных баг-трекинговых системах.  
 - ***Окружение (Environment)*** – окружение, на котором воспроизвелся баг.  
  
**СТАДИИ ЖИЗНЕННОГО ЦИКЛА ОШИБКИ:**  
   1. Тестировщик обнаруживает дефект  
   2. Тестировщик пишет отчет об ошибке в систему управления дефектами (статус ***New (новый)***) и перенаправляет его на разработчика (статус ***Assigned (назначен)***)  
   3. Разработчик изучает ошибку, ее возможности воспроизведения и по полученным результатам соотносит ее к одному из статусов:  
    - ***Duplicate (дубликат)*** – подобный дефект уже существует в системе по отслеживанию ошибок  
    - ***Rejected (отклонен)*** – ошибка не требует внесения корректив, поскольку ее влияние на продукт незначительное  
    - ***Deferred (отсрочен)*** – корректировку данной ошибки можно осуществить в другой версии программы  
    - ***Not a bug (не баг)*** – дефект не есть ошибкой, поэтому вносит коррективы не требуется  
    - ***Open (открыт)*** – дефект в процессе исправления  
    - ***Fixed (исправлен)*** – код изменен и протестирован разработчиком  
   4. Тестировщик повторно проверяет ошибку (статус ***«Retesting» (повторное тестирование)***)  
   5. Если дефект исправлен, тестировщик его закрывает (статусы ***«Verified» (проверен)***, затем ***«Closed» (закрыт)***)  
   6. Если дефект проявляется и дальше, он опять передается на редактирование разработчику (статусы ***«Reopened» (переоткрыт)***, ***«Assigned» (назначен)***) 
и вновь проходит через каждую стадию цикла  
</details>  
  
<details><summary><b>Severity vs Priority</b></summary></br>  
  
**Серьёзность (severity)** показывает степень ущерба, который наносится проекту существованием дефекта. 
Severity выставляется тестировщиком.  
  
**Градация Серьезности дефекта (Severity):**
 1. ***Блокирующий (S1 – Blocker)***  
тестирование значительной части функциональности вообще недоступно. Блокирующая ошибка, приводящая приложение в 
нерабочее состояние, в результате которого дальнейшая работа с тестируемой системой или ее ключевыми функциями становится невозможна. 
Пример: сайт не открывается или выдаёт ошибку при любом действии.  
 2. ***Критический (S2 – Critical)***  
критическая ошибка, неправильно работающая ключевая бизнес-логика, дыра в системе безопасности, проблема, приведшая к временному 
падению сервера или приводящая в нерабочее состояние некоторую часть системы, то есть не работает важная часть одной какой-либо 
функции либо не работает значительная часть, но имеется workaround (обходной путь/другие входные точки), позволяющий продолжить тестирование. 
Пример: 
  - в интернет-магазине не работает функция оплаты картой. Заказ можно оформить, но для оплаты приходится связываться с менеджерами  
  - нажимаете на кнопку "Поиск" и получаете ошибку "HTTP Error 500 Internal server error  
  - при регистрации е-мейл пользователя не вставляется в определенную колонку определенной таблицы базы данных  
 3. ***Значительный (S3 – Major)***  
не работает важная часть одной какой-либо функции/бизнес-логики, но при выполнении специфических условий, либо есть workaround, 
позволяющий продолжить ее тестирование либо не работает не очень значительная часть какой-либо функции. Также относится к дефектам
с высокими visibility – обычно не сильно влияющие на функциональность дефекты дизайна, которые, однако, сразу бросаются в глаза. 
Пример: при нажатии на кнопку “Оставить почту и получить скидку”, пользователю автоматически назначается скидка даже если он не оставил контакты.  
 4. ***Незначительный (S4 – Minor)***  
часто ошибки GUI, которые не влияют на функциональность, но портят юзабилити или внешний вид. Также незначительные функциональные 
дефекты, либо которые воспроизводятся на определенном устройстве. Пример: неправильно масштабируется рекламный баннер при уменьшении окна. 
Наплывающие друг на друга кнопки.  
 5. ***Тривиальный (S5 – Trivial)***  
почти всегда дефекты на GUI — опечатки в тексте, несоответствие шрифта и оттенка и т.п., либо плохо воспроизводимая ошибка, не касающаяся 
бизнес-логики, проблема сторонних библиотек или сервисов, проблема, не оказывающая никакого влияния на общее качество продукта.  
  
**Срочность (priority)** показывает, как быстро дефект должен быть устранён. Priority выставляется менеджером, тимлидом или заказчиком. Это показатель важности бага
для бизнеса компании.  
  
**Градация Приоритета дефекта (Priority):**   
  1. ***P1 - Высокий (High)***  
Критическая для проекта ошибка. Должна быть исправлена как можно быстрее.  
  2. ***P2 - Средний (Medium)***  
Не критичная для проекта ошибка, однако требует обязательного решения.  
  3. ***P3 - Низкий (Low)***  
Наличие данной ошибки не является критичным и не требует срочного решения. Может быть исправлена, когда у команды появится время на ее устранение.  
  
Коренное различие между ***priority*** и ***severity*** кроется в том, что серьезность отражает технический аспект бага, а приоритет — коммерческий. Серьезность — это категория абсолютная. Приоритет — это категория относительная.  
  
**Высокий приоритет и низкая серьезность**  
Такое сочетание бывает, когда баг на функционал влияет незначительно, но зато на пользовательский опыт влияет очень сильно. Также в эту категорию 
попадают баги, не влияющие на программу, но требующие исправления.  
1. *Кнопки перекрывают друг друга. Они кликабельны, но визуальное впечатление портится.*  
2. *Логотип компании на главной странице содержит орфографическую ошибку. На функционал это вообще не влияет, но портит пользовательский опыт. 
Этот баг нужно исправить с высоким приоритетом, несмотря не то, что на продукт он влияет минимально.*  
  
**Высокая серьезность и низкий приоритет**  
Такое сочетание бывает у багов, которые возникают в отдельных функциях программы. Эти баги не позволяют пользоваться системой, при этом
 обойти их невозможно. Но сами функции, содержащие эти дефекты, конечным потребителем используются редко.  
1. *Домашняя страница сайта ужасно выглядит в старых браузерах. Перекрывается текст, не загружается логотип. Это мешает пользоваться продуктом, 
поэтому серьезность бага высокая. Но так как очень мало пользователей открывают сайт при помощи устаревшего браузера, такой баг получает низкий приоритет*   
2. *Допустим, у нас есть приложение для банкинга. Оно правильно рассчитывает ежедневный, ежемесячный и ежеквартальный отчет, но при расчете годового 
возникают проблемы. Этот баг имеет высокую степень серьезности. Но если сейчас формирование годовой отчетности не актуально, такой дефект имеет низкий 
приоритет: его можно исправить в следующем релизе.*  
</details>  
  
<details><summary><b>Основные виды тестирования ПО</b></summary></br>   
  
**Вид тестирования** — это совокупность активностей, направленных на тестирование заданных характеристик системы или её части, основанная на конкретных целях.  
  
1. Классификация по запуску кода на исполнение:  
 - **Статическое тестирование** — процесс тестирования, который проводится для верификации практически любого артефакта разработки: программного кода компонент, требований, системных спецификаций, функциональных спецификаций, документов проектирования и архитектуры программных систем и их компонентов.  
 - **Динамическое тестирование** — тестирование проводится на работающей системе, не может быть осуществлено без запуска программного кода приложения.
  
2. Классификация по знанию кода:  
 - **Тестирование белого ящика** — метод тестирования ПО, который предполагает полный доступ к коду проекта.  
 - **Тестирование серого ящика** — метод тестирования ПО, который предполагает частичный доступ к коду проекта (комбинация White Box и Black Box методов).  
 - **Тестирование чёрного ящика** — метод тестирования ПО, который не предполагает доступа к системе. Основывается на работе исключительно с внешним интерфейсом тестируемой системы. К примеру, тестирование сайта, не зная особенностей его реализации, используя только предусмотренные разработчиком поля ввода и кнопки.  
  
3. Классификация по степени автоматизации:  
- **Ручное тестирование** – исполнение тестов вручную, без использования средств автоматизации.  
- **Автоматизированное тестирование** – подразумевает использование специального ПО. Помогает автоматизировать часто повторяющиеся, но необходимые для максимизации тестового покрытия задачи.  
Основные объекты для автоматизации: регрессионное тестирование, смок тестирование   
  
4. Классификация по принципам работы с приложением:  
 - **Позитивное тестирование** — тестирование, при котором используются только корректные данные. Выполняется в первую очередь.  
 - **Негативное тестирование** — тестирование приложения, при котором используются некорректные данные и выполняются некорректные операции.  
  
5. Классификация по степени важности:  
 - **Дымовое тестирование (smoke test)** — тестирование, выполняемое на новой сборке, с целью подтверждения того, что программное обеспечение стартует и выполняет основные для бизнеса функции. На примере *интернет-магазина: это один тест кейс, когда мы авторизуемся в системе – ищем товар – добавляем его в корзину – производим оплату – подтверждаем ее – получаем заказ.*   
Смок тест отвечает только либо ДА, либо НЕТ, то есть пройден кейс или нет. Должны быть быстрыми и легковесными, что бы можно было часто их запускать.  
 - **Тестирование критического пути (critical path)** — направлено для проверки функциональности, используемой обычными пользователями во время их повседневной деятельности. Типичный пользователь в повседневной жизни выполняет типичные задачи. Чаще всего на практике на данном уровне тестирования проверяется основная масса требований к продукту. Пример: *возможность набора текста, вставки картинок, возможность войти на сайт, создать запись, и т.д.*  
 - **Расширенное тестирование (extended)** — тестирование, при котором проверяется нестандартное использование программного продукта, границы переполнения массивов данных, ввод специальных символов, нелогичное клики по кнопкам, открыть одно окно и закрыть предыдущее, и так далее.  
  
6. Классификация в зависимости от исполнителей:  
 - **Альфа-тестирование** — является ранней версией программного продукта. Может выполняться внутри организации-разработчика с возможным частичным привлечением конечных пользователей.  
 - **Бета-тестирование** — программное обеспечение, выпускаемое для ограниченного количества пользователей (фокус группа). Главная цель — получить фидбэк клиентов о продукте и внести соответствующие изменения.  
  
7. Классификация по исполнению сценария:  
 - **Ad-hoc тестирование** – тестирование без спецификаций, планов и разработанных тест кейсов (импровизация).  
 - **Исследовательское тестирование** – каждый последующий тест выбирается на основании результатов предыдущего.  
 - **Сценарное тестирование** – классическое тестирование по предварительно написанным и задокументированным тестовым сценариям.  
  
8. Классификация по целям тестирования:  
 - **Функциональное тестирование (functional testing)** — направлено на проверку корректности работы функциональности приложения. Основная задача – подтвердить, что продукт обладает всем функционалом, который необходим заказчику.   
 - **Нефункциональное тестирование (non-functional testing)** — тестирование свойств компонента или системы, которые не относящихся к функциональности.  
      1. **Тестирование производительности (performance testing)** — определение стабильности и потребления ресурсов в условиях различных сценариев использования и нагрузок.  
          + **Нагрузочное тестирование (load testing)** — определение или сбор показателей производительности и времени отклика программно-технической системы или устройства в ответ на внешний запрос с целью установления соответствия требованиям, предъявляемым к данной системе (устройству).  
          + **Стрессовое тестирование (stress testing)** — тип тестирования, направленный для проверки, как система обращается с нарастающей нагрузкой (количеством одновременных пользователей).  
          +  **Объёмное тестирование (volume testing)** — это тип тестирования программного обеспечения, которое проводится для тестирования программного приложения с увеличением объемов данных. 
          +  **Тестирование надёжности (reliability testing)** — один из видов нефункционального тестирования ПО, целью которого является проверка работоспособности приложения при длительном тестировании с ожидаемым уровнем нагрузки.  
      
      2. **Тестирование на отказ и восстановление** – тестирование системы на предмет восстановления после ошибок и сбоев. Тестирование на отказ и восстановление очень важно для систем, работающих по принципу “24x7”. Если Вы создаете продукт, который будет работать, например в интернете, то без проведения данного вида тестирования Вам просто не обойтись так как каждая минута простоя или потеря данных в случае отказа оборудования, может стоить вам денег, потери клиентов и репутации на рынке.  
      3. **Тестирование масштабируемости (scalability testing)** — тестирование, которое измеряет производительность сети или системы, когда количество пользовательских запросов увеличивается или уменьшается.  
      4. **Тестирование установки (installation testing)** — тестирование, направленное на проверку успешной установки и настройки, обновления или удаления приложения.
      5. **Конфигурационное тестирование** – исследование работоспособности программной системы в условиях различных программных конфигураций.  
            - Кроссплатформенное тестирование  
            - Кросс браузерное тестирование    
      6. **Тестирование интерфейса (GUI/UI testing)** — проверка соответствия требований к графическому интерфейсу.  
      7. **Тестирование доступности** - проверка соответствия ПО общепризнанным стандартам доступности. Доступность системы людям с ограниченными возможностями.   
      8. **Тестирование удобства использования (usability testing)** — это метод тестирования, направленный на установление степени удобства использования, понятности и привлекательности для пользователей разрабатываемого продукта в контексте заданных условий.  
      9. **Тестирование локализации (localization testing) l10n** — проверка адаптации программного обеспечения для определенной аудитории в соответствии с ее языковыми и культурными особенностями.  
      10. **Тестирование безопасности (security testing)** — это стратегия тестирования, используемая для проверки безопасности системы, а также для анализа рисков, связанных с обеспечением целостного подхода к защите приложения, атак хакеров, вирусов, несанкционированного доступа к конфиденциальным данным. Тестирование защищенности ПО.   
      11. **Санитарное или Санити тестирование (Sanity Testing)** - относится к виду тестирования, которое используется с целью доказательства работоспособности конкретной функции или модуля согласно заявленным техническим требованиям. Зачастую санитарное тестирование используют для проверки какой либо части программы или приложения в результате внесенных изменений на нее со стороны факторов окружающей среды.  
      12. **Регрессионное тестирование (regression testing)** — тестирование уже проверенной ранее функциональности после внесения изменений в код приложения (к примеру, починка дефекта, слияние кода, миграция на другую операционную систему, базу данных, веб сервер или сервер приложения), для уверенности в том, что эти изменения не внесли ошибки в областях, которые не подверглись изменениям. Выбор тестов для регрессии:  
          - Безопасность, критичные для бизнеса функции  
          - Часто меняющиеся области  
          - Модули с высокой вероятностью ошибки  
      13. **Повторное/подтверждающее тестирование (re-testing/confirmation testing)** — тестирование, во время которого исполняются тестовые сценарии, выявившие ошибки во время последнего запуска, для подтверждения успешности исправления этих ошибок.  
</details>

<details><summary><b>Техники тест-дизайна</b></summary></br> 
  
**Тест-дизайн** — это этап тестирования ПО, на котором проектируются и создаются тестовые случаи.  
  
Техники тест-дизайна:  
 1. **Тестирование на основе классов эквивалентности (equivalence partitioning)** — это техника, при которой функционал (часто диапазон возможных вводимых значений) разделяется на группы эквивалентных по своему влиянию на систему значений.  
Пример 1: есть диапазон допустимых значений от 1 до 10, выбирается одно верное значение внутри интервала (например, 5) и одно неверное значение вне интервала — 0.  
Пример 2: есть четыре возрастных группы: младше 15 лет, от 15 до 25 лет, старше 25 и младше 60 лет и люди старше 60. При этом, в поле для ввода возраста помещается всего два символа, поэтому указать возраст более 99 лет технически невозможно. QA-специалисту не нужно писать 99 тестов для каждого возраста, хватит пяти: по одному для каждой возрастной группы (скажем, 10, 18, 35 и 75 лет) и один для случая, если возраст человека превышает 99 лет. Да, последний тест на практике невыполним (поскольку в поле возраста невозможно ввести более двух знаков), и все же не следует забывать об этой проверке.    
  
 2. **Техника анализа граничных значений (boundary value testing)** — это техника проверки поведения продукта на крайних (граничных) значениях входных данных. 
Для примера из предыдущего пункта границами будут являться значения 0, 15, 25, 60 и 99. Граничными значениями будут 0, 1, 14, 15, 16, 24, 25, 26, 59, 60, 61, 98, 99, 100.  
  
 3. **Попарное тестирование (pairwise testing)** — это техника формирования наборов тестовых данных из полного набора входных данных в системе, которая позволяет существенно сократить количество тест-кейсов. Используется для тестирования, например, фильтров, сортировок.  
   
 4. **Тестирование на основе состояний и переходов (State-Transition Testing)** — применяется для фиксирования требований и описания дизайна приложения.  
   
 5. **Предугадывание ошибки (Error Guessing — EG)**. Это когда тестировщик использует свои знания системы и способность к интерпретации спецификации на предмет того, чтобы «предугадать» при каких входных условиях система может выдать ошибку.  
   
 6. **Исчерпывающее тестирование (Exhaustive Testing — ET)** — подразумевается проверка всех возможные комбинации входных значений. На практике не используется.  
   
 7. **Таблицы принятия решений (Decision Table Testing)** — показывает возможные комбинации входных данных и ожидаемых результатов.  
   
 8. **Доменный анализ (Domain Analysis Testing)** — это техника основана на разбиении диапазона возможных значений переменной на поддиапазоны, с последующим выбором одного или нескольких значений из каждого домена для тестирования.  
 9. **Сценарий использования (Use Case Testing)** — Use Case описывает сценарий взаимодействия двух и более участников (как правило — пользователя и системы).  
</details>  

<details> <summary><b>Тестовая документация</b></summary></br> 
  
**Тест план (Test Plan)** — это документ, который описывает весь объем работ по тестированию, начиная с описания объекта, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков.  
  
**Критерии начала тестирования:**  
 - готовность тестовой платформы (тестового стенда)  
 - законченность разработки требуемого функционала  
 - наличие всей необходимой документации  
  
Следует выделить 3 основных **критерия для остановки, завершения тестирования:**
 - Время  
 - Бюджет  
 - Все тест кейсы пройдены, найденные баги исправлены и перепроверены  
  
Основные пункты, из которых может состоять тест-план перечислены в стандарте IEEE 829.  
Неотъемлемой частью тест-плана является **Traceability matrix** — Матрица соответствия требований (МСТ) — это таблица, содержащая соответствие функциональных требований (functional requirements) продукта и подготовленных тестовых сценариев (test cases). В заголовках колонок таблицы расположены требования, а в заголовках строк — тестовые сценарии. На пересечении — отметка, означающая, что требование текущей колонки покрыто тестовым сценарием текущей строки. МСТ используется для покрытия продукта тестами.  
  
**Тестовая стратегия** — определяет то, как мы тестируем продукт. Это набор мыслей и идей, которые направляют процесс тестирования. Дополняет тест-план и содержит общий подход к тестированию. По большому счёту правильная тестовая стратегия:
 - обозначает цели  
 - показывает, что нужно предпринять для достижения результата.
  
**Пользовательские истории (User Story)** — способ описания требований к разрабатываемой системе, сформулированных как одно или более предложений на повседневном или деловом языке пользователя. Пользовательские истории используются гибкими методологиями разработки программного обеспечения для спецификации требований.
User Story  —  это короткая формулировка намерения, описывающая что-то, что система должна делать для пользователя.  
Примеры:  
 - Залогиниться в мой портал мониторинга энергопотребления.  
 - Посмотреть ежедневный уровень потребления.  
 - Проверить мой текущий тариф.  
  
**Чек-лист (check list)** — это документ, содержащий список проверок того, что должно быть протестировано. Содержит результат проверок. Чаще всего чек-лист содержит только действия, без ожидаемого результата. Чек-лист менее формализован.  
  
**Тестовый сценарий (test case)** — это документ, описывающий совокупность шагов, конкретных условий и параметров, необходимых для проверки реализации тестируемой функции или её части.  
Атрибуты тест кейса:  
 - *Идентификатор*  
 - *Заглавие*  
 - *Предусловия (PreConditions)* — список действий, которые приводят систему к состоянию пригодному для проведения основной проверки. Либо список условий, выполнение которых говорит о том, что система находится в пригодном для проведения основного теста состояния.  
 - *Шаги (Steps)* — список действий, переводящих систему из одного состояния в другое, для получения результата, на основании которого можно сделать вывод о удовлетворении реализации, поставленным требованиям.  
 - *Ожидаемый результат (Expected result)*  
 - *Фактический результат*
Системы управления тест кейсами: **TestRail, TestLink, плагины для JIRA (Zephyr, Xray).**

**Тест Сьют (тестовый набор)** — это набор тест кейсов, которые объединены тем, что относятся к одному тестируемому модулю, функциональности, приоритету или одному типу тестирования. Каждый тест сьют состоит из более чем одного тест кейса и зачастую выполняется всей «пачкой» в процессе тестирования.  
</details>
  
<details> <summary><b>Метрики тестирования</b></summary></br>  
  
**Метрика тестирования ПО** — это критерий для отслеживания эффективности усилий по обеспечению качества. Сначала вы устанавливаете показатели успеха на этапе планирования. Затем сравниваете их с полученной метрикой после завершения процесса.  
1. **Удовлетворенность пользователей** - опросы об удовлетворенности пользователей и тикеты поддержки, которые выявляют ошибки.  
2. **Тестовое покрытие** — это «плотность» покрытия тестами выполняемого программного кода ПО или требований к нему. Чем больше проверок будет создано, тем высшего уровня достигнет тестовое покрытие на любом проекте. Но, стоит понимать, что до полного покрытия «дойти» не выйдет, поскольку протестировать все 100% наполненности ПО никогда не получится!  
Оценка тестового покрытия содержит сразу несколько методологических подходов, а именно:  
  - Покрытие требований  
  - Покрытие программного кода (Логика метрики обсчитывается по такой формуле:  
Тестовое покрытие программного кода= (количество строк кода, покрытых тест-кейсами/общее количество строк кода)x100%)  
3. **% дефектов, найденных пользователями** - (Дефектов выявлено пользователями / Всего зарегистрировано дефектов) × 100%  
4. **Покрытие GUI** - (Объектов покрыто тестами / Всего объектов) × 100%  
Где в качестве объектов могут выступать:  
  - Экранные формы
  - Элементы графического интерфейса  
5. **Покрытие API** - (Объектов покрыто тестами / Всего объектов) × 100%   
Где в качестве объектов могут выступать:  
  - Функции API  
  - Интерфейсы интеграции   
</details>  
